// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/kcarretto/realm/tavern/ent/deploymentconfig"
	"github.com/kcarretto/realm/tavern/ent/file"
	"github.com/kcarretto/realm/tavern/ent/implantconfig"
)

// DeploymentConfig is the model entity for the DeploymentConfig schema.
type DeploymentConfig struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Name holds the value of the "name" field.
	// Human-readable name assigned to this deployment config (e.g. 'Deploy Imix').
	Name string `json:"name,omitempty"`
	// Cmd holds the value of the "cmd" field.
	// Command to execute on target during deployment. It may contain templated vars such as {{B64_IMPLANT_CFG}}.
	Cmd string `json:"cmd,omitempty"`
	// StartCmd holds the value of the "startCmd" field.
	// If set to true, start the cmd and disown it. No cmd output will be available.
	StartCmd bool `json:"startCmd,omitempty"`
	// FileDst holds the value of the "fileDst" field.
	// If there is a file associated with this deployment config, it will be deployed to this location on the target system.
	FileDst string `json:"fileDst,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the DeploymentConfigQuery when eager-loading is set.
	Edges                            DeploymentConfigEdges `json:"edges"`
	deployment_config_file           *int
	deployment_config_implant_config *int
}

// DeploymentConfigEdges holds the relations/edges for other nodes in the graph.
type DeploymentConfigEdges struct {
	// Deployments holds the value of the deployments edge.
	Deployments []*Deployment `json:"deployments,omitempty"`
	// File holds the value of the file edge.
	File *File `json:"file,omitempty"`
	// ImplantConfig holds the value of the implantConfig edge.
	ImplantConfig *ImplantConfig `json:"implantConfig,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [3]bool
}

// DeploymentsOrErr returns the Deployments value or an error if the edge
// was not loaded in eager-loading.
func (e DeploymentConfigEdges) DeploymentsOrErr() ([]*Deployment, error) {
	if e.loadedTypes[0] {
		return e.Deployments, nil
	}
	return nil, &NotLoadedError{edge: "deployments"}
}

// FileOrErr returns the File value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e DeploymentConfigEdges) FileOrErr() (*File, error) {
	if e.loadedTypes[1] {
		if e.File == nil {
			// The edge file was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: file.Label}
		}
		return e.File, nil
	}
	return nil, &NotLoadedError{edge: "file"}
}

// ImplantConfigOrErr returns the ImplantConfig value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e DeploymentConfigEdges) ImplantConfigOrErr() (*ImplantConfig, error) {
	if e.loadedTypes[2] {
		if e.ImplantConfig == nil {
			// The edge implantConfig was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: implantconfig.Label}
		}
		return e.ImplantConfig, nil
	}
	return nil, &NotLoadedError{edge: "implantConfig"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*DeploymentConfig) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case deploymentconfig.FieldStartCmd:
			values[i] = new(sql.NullBool)
		case deploymentconfig.FieldID:
			values[i] = new(sql.NullInt64)
		case deploymentconfig.FieldName, deploymentconfig.FieldCmd, deploymentconfig.FieldFileDst:
			values[i] = new(sql.NullString)
		case deploymentconfig.ForeignKeys[0]: // deployment_config_file
			values[i] = new(sql.NullInt64)
		case deploymentconfig.ForeignKeys[1]: // deployment_config_implant_config
			values[i] = new(sql.NullInt64)
		default:
			return nil, fmt.Errorf("unexpected column %q for type DeploymentConfig", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the DeploymentConfig fields.
func (dc *DeploymentConfig) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case deploymentconfig.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			dc.ID = int(value.Int64)
		case deploymentconfig.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				dc.Name = value.String
			}
		case deploymentconfig.FieldCmd:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field cmd", values[i])
			} else if value.Valid {
				dc.Cmd = value.String
			}
		case deploymentconfig.FieldStartCmd:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field startCmd", values[i])
			} else if value.Valid {
				dc.StartCmd = value.Bool
			}
		case deploymentconfig.FieldFileDst:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field fileDst", values[i])
			} else if value.Valid {
				dc.FileDst = value.String
			}
		case deploymentconfig.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field deployment_config_file", value)
			} else if value.Valid {
				dc.deployment_config_file = new(int)
				*dc.deployment_config_file = int(value.Int64)
			}
		case deploymentconfig.ForeignKeys[1]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field deployment_config_implant_config", value)
			} else if value.Valid {
				dc.deployment_config_implant_config = new(int)
				*dc.deployment_config_implant_config = int(value.Int64)
			}
		}
	}
	return nil
}

// QueryDeployments queries the "deployments" edge of the DeploymentConfig entity.
func (dc *DeploymentConfig) QueryDeployments() *DeploymentQuery {
	return (&DeploymentConfigClient{config: dc.config}).QueryDeployments(dc)
}

// QueryFile queries the "file" edge of the DeploymentConfig entity.
func (dc *DeploymentConfig) QueryFile() *FileQuery {
	return (&DeploymentConfigClient{config: dc.config}).QueryFile(dc)
}

// QueryImplantConfig queries the "implantConfig" edge of the DeploymentConfig entity.
func (dc *DeploymentConfig) QueryImplantConfig() *ImplantConfigQuery {
	return (&DeploymentConfigClient{config: dc.config}).QueryImplantConfig(dc)
}

// Update returns a builder for updating this DeploymentConfig.
// Note that you need to call DeploymentConfig.Unwrap() before calling this method if this DeploymentConfig
// was returned from a transaction, and the transaction was committed or rolled back.
func (dc *DeploymentConfig) Update() *DeploymentConfigUpdateOne {
	return (&DeploymentConfigClient{config: dc.config}).UpdateOne(dc)
}

// Unwrap unwraps the DeploymentConfig entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (dc *DeploymentConfig) Unwrap() *DeploymentConfig {
	tx, ok := dc.config.driver.(*txDriver)
	if !ok {
		panic("ent: DeploymentConfig is not a transactional entity")
	}
	dc.config.driver = tx.drv
	return dc
}

// String implements the fmt.Stringer.
func (dc *DeploymentConfig) String() string {
	var builder strings.Builder
	builder.WriteString("DeploymentConfig(")
	builder.WriteString(fmt.Sprintf("id=%v", dc.ID))
	builder.WriteString(", name=")
	builder.WriteString(dc.Name)
	builder.WriteString(", cmd=")
	builder.WriteString(dc.Cmd)
	builder.WriteString(", startCmd=")
	builder.WriteString(fmt.Sprintf("%v", dc.StartCmd))
	builder.WriteString(", fileDst=")
	builder.WriteString(dc.FileDst)
	builder.WriteByte(')')
	return builder.String()
}

// DeploymentConfigs is a parsable slice of DeploymentConfig.
type DeploymentConfigs []*DeploymentConfig

func (dc DeploymentConfigs) config(cfg config) {
	for _i := range dc {
		dc[_i].config = cfg
	}
}
