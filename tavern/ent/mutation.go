// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/kcarretto/realm/tavern/ent/credential"
	"github.com/kcarretto/realm/tavern/ent/deployment"
	"github.com/kcarretto/realm/tavern/ent/deploymentconfig"
	"github.com/kcarretto/realm/tavern/ent/file"
	"github.com/kcarretto/realm/tavern/ent/implant"
	"github.com/kcarretto/realm/tavern/ent/implantcallbackconfig"
	"github.com/kcarretto/realm/tavern/ent/implantconfig"
	"github.com/kcarretto/realm/tavern/ent/implantserviceconfig"
	"github.com/kcarretto/realm/tavern/ent/predicate"
	"github.com/kcarretto/realm/tavern/ent/tag"
	"github.com/kcarretto/realm/tavern/ent/target"
	"github.com/kcarretto/realm/tavern/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCredential            = "Credential"
	TypeDeployment            = "Deployment"
	TypeDeploymentConfig      = "DeploymentConfig"
	TypeFile                  = "File"
	TypeImplant               = "Implant"
	TypeImplantCallbackConfig = "ImplantCallbackConfig"
	TypeImplantConfig         = "ImplantConfig"
	TypeImplantServiceConfig  = "ImplantServiceConfig"
	TypeTag                   = "Tag"
	TypeTarget                = "Target"
	TypeUser                  = "User"
)

// CredentialMutation represents an operation that mutates the Credential nodes in the graph.
type CredentialMutation struct {
	config
	op            Op
	typ           string
	id            *int
	principal     *string
	secret        *string
	kind          *credential.Kind
	clearedFields map[string]struct{}
	target        *int
	clearedtarget bool
	done          bool
	oldValue      func(context.Context) (*Credential, error)
	predicates    []predicate.Credential
}

var _ ent.Mutation = (*CredentialMutation)(nil)

// credentialOption allows management of the mutation configuration using functional options.
type credentialOption func(*CredentialMutation)

// newCredentialMutation creates new mutation for the Credential entity.
func newCredentialMutation(c config, op Op, opts ...credentialOption) *CredentialMutation {
	m := &CredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCredentialID sets the ID field of the mutation.
func withCredentialID(id int) credentialOption {
	return func(m *CredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *Credential
		)
		m.oldValue = func(ctx context.Context) (*Credential, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Credential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCredential sets the old Credential of the mutation.
func withCredential(node *Credential) credentialOption {
	return func(m *CredentialMutation) {
		m.oldValue = func(context.Context) (*Credential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CredentialMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CredentialMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Credential.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPrincipal sets the "principal" field.
func (m *CredentialMutation) SetPrincipal(s string) {
	m.principal = &s
}

// Principal returns the value of the "principal" field in the mutation.
func (m *CredentialMutation) Principal() (r string, exists bool) {
	v := m.principal
	if v == nil {
		return
	}
	return *v, true
}

// OldPrincipal returns the old "principal" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldPrincipal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrincipal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrincipal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrincipal: %w", err)
	}
	return oldValue.Principal, nil
}

// ResetPrincipal resets all changes to the "principal" field.
func (m *CredentialMutation) ResetPrincipal() {
	m.principal = nil
}

// SetSecret sets the "secret" field.
func (m *CredentialMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *CredentialMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *CredentialMutation) ResetSecret() {
	m.secret = nil
}

// SetKind sets the "kind" field.
func (m *CredentialMutation) SetKind(c credential.Kind) {
	m.kind = &c
}

// Kind returns the value of the "kind" field in the mutation.
func (m *CredentialMutation) Kind() (r credential.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldKind(ctx context.Context) (v credential.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *CredentialMutation) ResetKind() {
	m.kind = nil
}

// SetTargetID sets the "target" edge to the Target entity by id.
func (m *CredentialMutation) SetTargetID(id int) {
	m.target = &id
}

// ClearTarget clears the "target" edge to the Target entity.
func (m *CredentialMutation) ClearTarget() {
	m.clearedtarget = true
}

// TargetCleared reports if the "target" edge to the Target entity was cleared.
func (m *CredentialMutation) TargetCleared() bool {
	return m.clearedtarget
}

// TargetID returns the "target" edge ID in the mutation.
func (m *CredentialMutation) TargetID() (id int, exists bool) {
	if m.target != nil {
		return *m.target, true
	}
	return
}

// TargetIDs returns the "target" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetID instead. It exists only for internal usage by the builders.
func (m *CredentialMutation) TargetIDs() (ids []int) {
	if id := m.target; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTarget resets all changes to the "target" edge.
func (m *CredentialMutation) ResetTarget() {
	m.target = nil
	m.clearedtarget = false
}

// Where appends a list predicates to the CredentialMutation builder.
func (m *CredentialMutation) Where(ps ...predicate.Credential) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CredentialMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Credential).
func (m *CredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CredentialMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.principal != nil {
		fields = append(fields, credential.FieldPrincipal)
	}
	if m.secret != nil {
		fields = append(fields, credential.FieldSecret)
	}
	if m.kind != nil {
		fields = append(fields, credential.FieldKind)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credential.FieldPrincipal:
		return m.Principal()
	case credential.FieldSecret:
		return m.Secret()
	case credential.FieldKind:
		return m.Kind()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credential.FieldPrincipal:
		return m.OldPrincipal(ctx)
	case credential.FieldSecret:
		return m.OldSecret(ctx)
	case credential.FieldKind:
		return m.OldKind(ctx)
	}
	return nil, fmt.Errorf("unknown Credential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credential.FieldPrincipal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrincipal(v)
		return nil
	case credential.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case credential.FieldKind:
		v, ok := value.(credential.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CredentialMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CredentialMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Credential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CredentialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CredentialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Credential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CredentialMutation) ResetField(name string) error {
	switch name {
	case credential.FieldPrincipal:
		m.ResetPrincipal()
		return nil
	case credential.FieldSecret:
		m.ResetSecret()
		return nil
	case credential.FieldKind:
		m.ResetKind()
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.target != nil {
		edges = append(edges, credential.EdgeTarget)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CredentialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credential.EdgeTarget:
		if id := m.target; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CredentialMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtarget {
		edges = append(edges, credential.EdgeTarget)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CredentialMutation) EdgeCleared(name string) bool {
	switch name {
	case credential.EdgeTarget:
		return m.clearedtarget
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CredentialMutation) ClearEdge(name string) error {
	switch name {
	case credential.EdgeTarget:
		m.ClearTarget()
		return nil
	}
	return fmt.Errorf("unknown Credential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CredentialMutation) ResetEdge(name string) error {
	switch name {
	case credential.EdgeTarget:
		m.ResetTarget()
		return nil
	}
	return fmt.Errorf("unknown Credential edge %s", name)
}

// DeploymentMutation represents an operation that mutates the Deployment nodes in the graph.
type DeploymentMutation struct {
	config
	op             Op
	typ            string
	id             *int
	output         *string
	error          *string
	queuedAt       *time.Time
	lastModifiedAt *time.Time
	startedAt      *time.Time
	finishedAt     *time.Time
	clearedFields  map[string]struct{}
	_config        *int
	cleared_config bool
	target         *int
	clearedtarget  bool
	done           bool
	oldValue       func(context.Context) (*Deployment, error)
	predicates     []predicate.Deployment
}

var _ ent.Mutation = (*DeploymentMutation)(nil)

// deploymentOption allows management of the mutation configuration using functional options.
type deploymentOption func(*DeploymentMutation)

// newDeploymentMutation creates new mutation for the Deployment entity.
func newDeploymentMutation(c config, op Op, opts ...deploymentOption) *DeploymentMutation {
	m := &DeploymentMutation{
		config:        c,
		op:            op,
		typ:           TypeDeployment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeploymentID sets the ID field of the mutation.
func withDeploymentID(id int) deploymentOption {
	return func(m *DeploymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Deployment
		)
		m.oldValue = func(ctx context.Context) (*Deployment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Deployment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeployment sets the old Deployment of the mutation.
func withDeployment(node *Deployment) deploymentOption {
	return func(m *DeploymentMutation) {
		m.oldValue = func(context.Context) (*Deployment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeploymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeploymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeploymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeploymentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Deployment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOutput sets the "output" field.
func (m *DeploymentMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *DeploymentMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ResetOutput resets all changes to the "output" field.
func (m *DeploymentMutation) ResetOutput() {
	m.output = nil
}

// SetError sets the "error" field.
func (m *DeploymentMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *DeploymentMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ResetError resets all changes to the "error" field.
func (m *DeploymentMutation) ResetError() {
	m.error = nil
}

// SetQueuedAt sets the "queuedAt" field.
func (m *DeploymentMutation) SetQueuedAt(t time.Time) {
	m.queuedAt = &t
}

// QueuedAt returns the value of the "queuedAt" field in the mutation.
func (m *DeploymentMutation) QueuedAt() (r time.Time, exists bool) {
	v := m.queuedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldQueuedAt returns the old "queuedAt" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldQueuedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueuedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueuedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueuedAt: %w", err)
	}
	return oldValue.QueuedAt, nil
}

// ResetQueuedAt resets all changes to the "queuedAt" field.
func (m *DeploymentMutation) ResetQueuedAt() {
	m.queuedAt = nil
}

// SetLastModifiedAt sets the "lastModifiedAt" field.
func (m *DeploymentMutation) SetLastModifiedAt(t time.Time) {
	m.lastModifiedAt = &t
}

// LastModifiedAt returns the value of the "lastModifiedAt" field in the mutation.
func (m *DeploymentMutation) LastModifiedAt() (r time.Time, exists bool) {
	v := m.lastModifiedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedAt returns the old "lastModifiedAt" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldLastModifiedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedAt: %w", err)
	}
	return oldValue.LastModifiedAt, nil
}

// ResetLastModifiedAt resets all changes to the "lastModifiedAt" field.
func (m *DeploymentMutation) ResetLastModifiedAt() {
	m.lastModifiedAt = nil
}

// SetStartedAt sets the "startedAt" field.
func (m *DeploymentMutation) SetStartedAt(t time.Time) {
	m.startedAt = &t
}

// StartedAt returns the value of the "startedAt" field in the mutation.
func (m *DeploymentMutation) StartedAt() (r time.Time, exists bool) {
	v := m.startedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "startedAt" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "startedAt" field.
func (m *DeploymentMutation) ClearStartedAt() {
	m.startedAt = nil
	m.clearedFields[deployment.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "startedAt" field was cleared in this mutation.
func (m *DeploymentMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[deployment.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "startedAt" field.
func (m *DeploymentMutation) ResetStartedAt() {
	m.startedAt = nil
	delete(m.clearedFields, deployment.FieldStartedAt)
}

// SetFinishedAt sets the "finishedAt" field.
func (m *DeploymentMutation) SetFinishedAt(t time.Time) {
	m.finishedAt = &t
}

// FinishedAt returns the value of the "finishedAt" field in the mutation.
func (m *DeploymentMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finishedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finishedAt" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finishedAt" field.
func (m *DeploymentMutation) ClearFinishedAt() {
	m.finishedAt = nil
	m.clearedFields[deployment.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finishedAt" field was cleared in this mutation.
func (m *DeploymentMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[deployment.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finishedAt" field.
func (m *DeploymentMutation) ResetFinishedAt() {
	m.finishedAt = nil
	delete(m.clearedFields, deployment.FieldFinishedAt)
}

// SetConfigID sets the "config" edge to the DeploymentConfig entity by id.
func (m *DeploymentMutation) SetConfigID(id int) {
	m._config = &id
}

// ClearConfig clears the "config" edge to the DeploymentConfig entity.
func (m *DeploymentMutation) ClearConfig() {
	m.cleared_config = true
}

// ConfigCleared reports if the "config" edge to the DeploymentConfig entity was cleared.
func (m *DeploymentMutation) ConfigCleared() bool {
	return m.cleared_config
}

// ConfigID returns the "config" edge ID in the mutation.
func (m *DeploymentMutation) ConfigID() (id int, exists bool) {
	if m._config != nil {
		return *m._config, true
	}
	return
}

// ConfigIDs returns the "config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConfigID instead. It exists only for internal usage by the builders.
func (m *DeploymentMutation) ConfigIDs() (ids []int) {
	if id := m._config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConfig resets all changes to the "config" edge.
func (m *DeploymentMutation) ResetConfig() {
	m._config = nil
	m.cleared_config = false
}

// SetTargetID sets the "target" edge to the Target entity by id.
func (m *DeploymentMutation) SetTargetID(id int) {
	m.target = &id
}

// ClearTarget clears the "target" edge to the Target entity.
func (m *DeploymentMutation) ClearTarget() {
	m.clearedtarget = true
}

// TargetCleared reports if the "target" edge to the Target entity was cleared.
func (m *DeploymentMutation) TargetCleared() bool {
	return m.clearedtarget
}

// TargetID returns the "target" edge ID in the mutation.
func (m *DeploymentMutation) TargetID() (id int, exists bool) {
	if m.target != nil {
		return *m.target, true
	}
	return
}

// TargetIDs returns the "target" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetID instead. It exists only for internal usage by the builders.
func (m *DeploymentMutation) TargetIDs() (ids []int) {
	if id := m.target; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTarget resets all changes to the "target" edge.
func (m *DeploymentMutation) ResetTarget() {
	m.target = nil
	m.clearedtarget = false
}

// Where appends a list predicates to the DeploymentMutation builder.
func (m *DeploymentMutation) Where(ps ...predicate.Deployment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeploymentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Deployment).
func (m *DeploymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeploymentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.output != nil {
		fields = append(fields, deployment.FieldOutput)
	}
	if m.error != nil {
		fields = append(fields, deployment.FieldError)
	}
	if m.queuedAt != nil {
		fields = append(fields, deployment.FieldQueuedAt)
	}
	if m.lastModifiedAt != nil {
		fields = append(fields, deployment.FieldLastModifiedAt)
	}
	if m.startedAt != nil {
		fields = append(fields, deployment.FieldStartedAt)
	}
	if m.finishedAt != nil {
		fields = append(fields, deployment.FieldFinishedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeploymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deployment.FieldOutput:
		return m.Output()
	case deployment.FieldError:
		return m.Error()
	case deployment.FieldQueuedAt:
		return m.QueuedAt()
	case deployment.FieldLastModifiedAt:
		return m.LastModifiedAt()
	case deployment.FieldStartedAt:
		return m.StartedAt()
	case deployment.FieldFinishedAt:
		return m.FinishedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeploymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deployment.FieldOutput:
		return m.OldOutput(ctx)
	case deployment.FieldError:
		return m.OldError(ctx)
	case deployment.FieldQueuedAt:
		return m.OldQueuedAt(ctx)
	case deployment.FieldLastModifiedAt:
		return m.OldLastModifiedAt(ctx)
	case deployment.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case deployment.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Deployment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deployment.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case deployment.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case deployment.FieldQueuedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueuedAt(v)
		return nil
	case deployment.FieldLastModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedAt(v)
		return nil
	case deployment.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case deployment.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Deployment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeploymentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeploymentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Deployment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeploymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deployment.FieldStartedAt) {
		fields = append(fields, deployment.FieldStartedAt)
	}
	if m.FieldCleared(deployment.FieldFinishedAt) {
		fields = append(fields, deployment.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeploymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeploymentMutation) ClearField(name string) error {
	switch name {
	case deployment.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case deployment.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown Deployment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeploymentMutation) ResetField(name string) error {
	switch name {
	case deployment.FieldOutput:
		m.ResetOutput()
		return nil
	case deployment.FieldError:
		m.ResetError()
		return nil
	case deployment.FieldQueuedAt:
		m.ResetQueuedAt()
		return nil
	case deployment.FieldLastModifiedAt:
		m.ResetLastModifiedAt()
		return nil
	case deployment.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case deployment.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown Deployment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeploymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._config != nil {
		edges = append(edges, deployment.EdgeConfig)
	}
	if m.target != nil {
		edges = append(edges, deployment.EdgeTarget)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeploymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deployment.EdgeConfig:
		if id := m._config; id != nil {
			return []ent.Value{*id}
		}
	case deployment.EdgeTarget:
		if id := m.target; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeploymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeploymentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeploymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_config {
		edges = append(edges, deployment.EdgeConfig)
	}
	if m.clearedtarget {
		edges = append(edges, deployment.EdgeTarget)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeploymentMutation) EdgeCleared(name string) bool {
	switch name {
	case deployment.EdgeConfig:
		return m.cleared_config
	case deployment.EdgeTarget:
		return m.clearedtarget
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeploymentMutation) ClearEdge(name string) error {
	switch name {
	case deployment.EdgeConfig:
		m.ClearConfig()
		return nil
	case deployment.EdgeTarget:
		m.ClearTarget()
		return nil
	}
	return fmt.Errorf("unknown Deployment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeploymentMutation) ResetEdge(name string) error {
	switch name {
	case deployment.EdgeConfig:
		m.ResetConfig()
		return nil
	case deployment.EdgeTarget:
		m.ResetTarget()
		return nil
	}
	return fmt.Errorf("unknown Deployment edge %s", name)
}

// DeploymentConfigMutation represents an operation that mutates the DeploymentConfig nodes in the graph.
type DeploymentConfigMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	cmd                  *string
	startCmd             *bool
	fileDst              *string
	clearedFields        map[string]struct{}
	deployments          map[int]struct{}
	removeddeployments   map[int]struct{}
	cleareddeployments   bool
	file                 *int
	clearedfile          bool
	implantConfig        *int
	clearedimplantConfig bool
	done                 bool
	oldValue             func(context.Context) (*DeploymentConfig, error)
	predicates           []predicate.DeploymentConfig
}

var _ ent.Mutation = (*DeploymentConfigMutation)(nil)

// deploymentconfigOption allows management of the mutation configuration using functional options.
type deploymentconfigOption func(*DeploymentConfigMutation)

// newDeploymentConfigMutation creates new mutation for the DeploymentConfig entity.
func newDeploymentConfigMutation(c config, op Op, opts ...deploymentconfigOption) *DeploymentConfigMutation {
	m := &DeploymentConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeDeploymentConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeploymentConfigID sets the ID field of the mutation.
func withDeploymentConfigID(id int) deploymentconfigOption {
	return func(m *DeploymentConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *DeploymentConfig
		)
		m.oldValue = func(ctx context.Context) (*DeploymentConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeploymentConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeploymentConfig sets the old DeploymentConfig of the mutation.
func withDeploymentConfig(node *DeploymentConfig) deploymentconfigOption {
	return func(m *DeploymentConfigMutation) {
		m.oldValue = func(context.Context) (*DeploymentConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeploymentConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeploymentConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeploymentConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeploymentConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeploymentConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DeploymentConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeploymentConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DeploymentConfig entity.
// If the DeploymentConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeploymentConfigMutation) ResetName() {
	m.name = nil
}

// SetCmd sets the "cmd" field.
func (m *DeploymentConfigMutation) SetCmd(s string) {
	m.cmd = &s
}

// Cmd returns the value of the "cmd" field in the mutation.
func (m *DeploymentConfigMutation) Cmd() (r string, exists bool) {
	v := m.cmd
	if v == nil {
		return
	}
	return *v, true
}

// OldCmd returns the old "cmd" field's value of the DeploymentConfig entity.
// If the DeploymentConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentConfigMutation) OldCmd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCmd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCmd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCmd: %w", err)
	}
	return oldValue.Cmd, nil
}

// ResetCmd resets all changes to the "cmd" field.
func (m *DeploymentConfigMutation) ResetCmd() {
	m.cmd = nil
}

// SetStartCmd sets the "startCmd" field.
func (m *DeploymentConfigMutation) SetStartCmd(b bool) {
	m.startCmd = &b
}

// StartCmd returns the value of the "startCmd" field in the mutation.
func (m *DeploymentConfigMutation) StartCmd() (r bool, exists bool) {
	v := m.startCmd
	if v == nil {
		return
	}
	return *v, true
}

// OldStartCmd returns the old "startCmd" field's value of the DeploymentConfig entity.
// If the DeploymentConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentConfigMutation) OldStartCmd(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartCmd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartCmd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartCmd: %w", err)
	}
	return oldValue.StartCmd, nil
}

// ResetStartCmd resets all changes to the "startCmd" field.
func (m *DeploymentConfigMutation) ResetStartCmd() {
	m.startCmd = nil
}

// SetFileDst sets the "fileDst" field.
func (m *DeploymentConfigMutation) SetFileDst(s string) {
	m.fileDst = &s
}

// FileDst returns the value of the "fileDst" field in the mutation.
func (m *DeploymentConfigMutation) FileDst() (r string, exists bool) {
	v := m.fileDst
	if v == nil {
		return
	}
	return *v, true
}

// OldFileDst returns the old "fileDst" field's value of the DeploymentConfig entity.
// If the DeploymentConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentConfigMutation) OldFileDst(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileDst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileDst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileDst: %w", err)
	}
	return oldValue.FileDst, nil
}

// ResetFileDst resets all changes to the "fileDst" field.
func (m *DeploymentConfigMutation) ResetFileDst() {
	m.fileDst = nil
}

// AddDeploymentIDs adds the "deployments" edge to the Deployment entity by ids.
func (m *DeploymentConfigMutation) AddDeploymentIDs(ids ...int) {
	if m.deployments == nil {
		m.deployments = make(map[int]struct{})
	}
	for i := range ids {
		m.deployments[ids[i]] = struct{}{}
	}
}

// ClearDeployments clears the "deployments" edge to the Deployment entity.
func (m *DeploymentConfigMutation) ClearDeployments() {
	m.cleareddeployments = true
}

// DeploymentsCleared reports if the "deployments" edge to the Deployment entity was cleared.
func (m *DeploymentConfigMutation) DeploymentsCleared() bool {
	return m.cleareddeployments
}

// RemoveDeploymentIDs removes the "deployments" edge to the Deployment entity by IDs.
func (m *DeploymentConfigMutation) RemoveDeploymentIDs(ids ...int) {
	if m.removeddeployments == nil {
		m.removeddeployments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.deployments, ids[i])
		m.removeddeployments[ids[i]] = struct{}{}
	}
}

// RemovedDeployments returns the removed IDs of the "deployments" edge to the Deployment entity.
func (m *DeploymentConfigMutation) RemovedDeploymentsIDs() (ids []int) {
	for id := range m.removeddeployments {
		ids = append(ids, id)
	}
	return
}

// DeploymentsIDs returns the "deployments" edge IDs in the mutation.
func (m *DeploymentConfigMutation) DeploymentsIDs() (ids []int) {
	for id := range m.deployments {
		ids = append(ids, id)
	}
	return
}

// ResetDeployments resets all changes to the "deployments" edge.
func (m *DeploymentConfigMutation) ResetDeployments() {
	m.deployments = nil
	m.cleareddeployments = false
	m.removeddeployments = nil
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *DeploymentConfigMutation) SetFileID(id int) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *DeploymentConfigMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *DeploymentConfigMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *DeploymentConfigMutation) FileID() (id int, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *DeploymentConfigMutation) FileIDs() (ids []int) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *DeploymentConfigMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// SetImplantConfigID sets the "implantConfig" edge to the ImplantConfig entity by id.
func (m *DeploymentConfigMutation) SetImplantConfigID(id int) {
	m.implantConfig = &id
}

// ClearImplantConfig clears the "implantConfig" edge to the ImplantConfig entity.
func (m *DeploymentConfigMutation) ClearImplantConfig() {
	m.clearedimplantConfig = true
}

// ImplantConfigCleared reports if the "implantConfig" edge to the ImplantConfig entity was cleared.
func (m *DeploymentConfigMutation) ImplantConfigCleared() bool {
	return m.clearedimplantConfig
}

// ImplantConfigID returns the "implantConfig" edge ID in the mutation.
func (m *DeploymentConfigMutation) ImplantConfigID() (id int, exists bool) {
	if m.implantConfig != nil {
		return *m.implantConfig, true
	}
	return
}

// ImplantConfigIDs returns the "implantConfig" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImplantConfigID instead. It exists only for internal usage by the builders.
func (m *DeploymentConfigMutation) ImplantConfigIDs() (ids []int) {
	if id := m.implantConfig; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImplantConfig resets all changes to the "implantConfig" edge.
func (m *DeploymentConfigMutation) ResetImplantConfig() {
	m.implantConfig = nil
	m.clearedimplantConfig = false
}

// Where appends a list predicates to the DeploymentConfigMutation builder.
func (m *DeploymentConfigMutation) Where(ps ...predicate.DeploymentConfig) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeploymentConfigMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DeploymentConfig).
func (m *DeploymentConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeploymentConfigMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, deploymentconfig.FieldName)
	}
	if m.cmd != nil {
		fields = append(fields, deploymentconfig.FieldCmd)
	}
	if m.startCmd != nil {
		fields = append(fields, deploymentconfig.FieldStartCmd)
	}
	if m.fileDst != nil {
		fields = append(fields, deploymentconfig.FieldFileDst)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeploymentConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deploymentconfig.FieldName:
		return m.Name()
	case deploymentconfig.FieldCmd:
		return m.Cmd()
	case deploymentconfig.FieldStartCmd:
		return m.StartCmd()
	case deploymentconfig.FieldFileDst:
		return m.FileDst()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeploymentConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deploymentconfig.FieldName:
		return m.OldName(ctx)
	case deploymentconfig.FieldCmd:
		return m.OldCmd(ctx)
	case deploymentconfig.FieldStartCmd:
		return m.OldStartCmd(ctx)
	case deploymentconfig.FieldFileDst:
		return m.OldFileDst(ctx)
	}
	return nil, fmt.Errorf("unknown DeploymentConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deploymentconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case deploymentconfig.FieldCmd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCmd(v)
		return nil
	case deploymentconfig.FieldStartCmd:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartCmd(v)
		return nil
	case deploymentconfig.FieldFileDst:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileDst(v)
		return nil
	}
	return fmt.Errorf("unknown DeploymentConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeploymentConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeploymentConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeploymentConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeploymentConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeploymentConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeploymentConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeploymentConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeploymentConfigMutation) ResetField(name string) error {
	switch name {
	case deploymentconfig.FieldName:
		m.ResetName()
		return nil
	case deploymentconfig.FieldCmd:
		m.ResetCmd()
		return nil
	case deploymentconfig.FieldStartCmd:
		m.ResetStartCmd()
		return nil
	case deploymentconfig.FieldFileDst:
		m.ResetFileDst()
		return nil
	}
	return fmt.Errorf("unknown DeploymentConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeploymentConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.deployments != nil {
		edges = append(edges, deploymentconfig.EdgeDeployments)
	}
	if m.file != nil {
		edges = append(edges, deploymentconfig.EdgeFile)
	}
	if m.implantConfig != nil {
		edges = append(edges, deploymentconfig.EdgeImplantConfig)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeploymentConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deploymentconfig.EdgeDeployments:
		ids := make([]ent.Value, 0, len(m.deployments))
		for id := range m.deployments {
			ids = append(ids, id)
		}
		return ids
	case deploymentconfig.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	case deploymentconfig.EdgeImplantConfig:
		if id := m.implantConfig; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeploymentConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddeployments != nil {
		edges = append(edges, deploymentconfig.EdgeDeployments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeploymentConfigMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deploymentconfig.EdgeDeployments:
		ids := make([]ent.Value, 0, len(m.removeddeployments))
		for id := range m.removeddeployments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeploymentConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddeployments {
		edges = append(edges, deploymentconfig.EdgeDeployments)
	}
	if m.clearedfile {
		edges = append(edges, deploymentconfig.EdgeFile)
	}
	if m.clearedimplantConfig {
		edges = append(edges, deploymentconfig.EdgeImplantConfig)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeploymentConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case deploymentconfig.EdgeDeployments:
		return m.cleareddeployments
	case deploymentconfig.EdgeFile:
		return m.clearedfile
	case deploymentconfig.EdgeImplantConfig:
		return m.clearedimplantConfig
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeploymentConfigMutation) ClearEdge(name string) error {
	switch name {
	case deploymentconfig.EdgeFile:
		m.ClearFile()
		return nil
	case deploymentconfig.EdgeImplantConfig:
		m.ClearImplantConfig()
		return nil
	}
	return fmt.Errorf("unknown DeploymentConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeploymentConfigMutation) ResetEdge(name string) error {
	switch name {
	case deploymentconfig.EdgeDeployments:
		m.ResetDeployments()
		return nil
	case deploymentconfig.EdgeFile:
		m.ResetFile()
		return nil
	case deploymentconfig.EdgeImplantConfig:
		m.ResetImplantConfig()
		return nil
	}
	return fmt.Errorf("unknown DeploymentConfig edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *string
	size                     *int
	addsize                  *int
	hash                     *string
	createdAt                *time.Time
	lastModifiedAt           *time.Time
	content                  *[]byte
	clearedFields            map[string]struct{}
	deploymentConfigs        map[int]struct{}
	removeddeploymentConfigs map[int]struct{}
	cleareddeploymentConfigs bool
	done                     bool
	oldValue                 func(context.Context) (*File, error)
	predicates               []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id int) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *FileMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetHash sets the "hash" field.
func (m *FileMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *FileMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *FileMutation) ResetHash() {
	m.hash = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *FileMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetLastModifiedAt sets the "lastModifiedAt" field.
func (m *FileMutation) SetLastModifiedAt(t time.Time) {
	m.lastModifiedAt = &t
}

// LastModifiedAt returns the value of the "lastModifiedAt" field in the mutation.
func (m *FileMutation) LastModifiedAt() (r time.Time, exists bool) {
	v := m.lastModifiedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedAt returns the old "lastModifiedAt" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldLastModifiedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedAt: %w", err)
	}
	return oldValue.LastModifiedAt, nil
}

// ResetLastModifiedAt resets all changes to the "lastModifiedAt" field.
func (m *FileMutation) ResetLastModifiedAt() {
	m.lastModifiedAt = nil
}

// SetContent sets the "content" field.
func (m *FileMutation) SetContent(b []byte) {
	m.content = &b
}

// Content returns the value of the "content" field in the mutation.
func (m *FileMutation) Content() (r []byte, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldContent(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *FileMutation) ResetContent() {
	m.content = nil
}

// AddDeploymentConfigIDs adds the "deploymentConfigs" edge to the DeploymentConfig entity by ids.
func (m *FileMutation) AddDeploymentConfigIDs(ids ...int) {
	if m.deploymentConfigs == nil {
		m.deploymentConfigs = make(map[int]struct{})
	}
	for i := range ids {
		m.deploymentConfigs[ids[i]] = struct{}{}
	}
}

// ClearDeploymentConfigs clears the "deploymentConfigs" edge to the DeploymentConfig entity.
func (m *FileMutation) ClearDeploymentConfigs() {
	m.cleareddeploymentConfigs = true
}

// DeploymentConfigsCleared reports if the "deploymentConfigs" edge to the DeploymentConfig entity was cleared.
func (m *FileMutation) DeploymentConfigsCleared() bool {
	return m.cleareddeploymentConfigs
}

// RemoveDeploymentConfigIDs removes the "deploymentConfigs" edge to the DeploymentConfig entity by IDs.
func (m *FileMutation) RemoveDeploymentConfigIDs(ids ...int) {
	if m.removeddeploymentConfigs == nil {
		m.removeddeploymentConfigs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.deploymentConfigs, ids[i])
		m.removeddeploymentConfigs[ids[i]] = struct{}{}
	}
}

// RemovedDeploymentConfigs returns the removed IDs of the "deploymentConfigs" edge to the DeploymentConfig entity.
func (m *FileMutation) RemovedDeploymentConfigsIDs() (ids []int) {
	for id := range m.removeddeploymentConfigs {
		ids = append(ids, id)
	}
	return
}

// DeploymentConfigsIDs returns the "deploymentConfigs" edge IDs in the mutation.
func (m *FileMutation) DeploymentConfigsIDs() (ids []int) {
	for id := range m.deploymentConfigs {
		ids = append(ids, id)
	}
	return
}

// ResetDeploymentConfigs resets all changes to the "deploymentConfigs" edge.
func (m *FileMutation) ResetDeploymentConfigs() {
	m.deploymentConfigs = nil
	m.cleareddeploymentConfigs = false
	m.removeddeploymentConfigs = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.hash != nil {
		fields = append(fields, file.FieldHash)
	}
	if m.createdAt != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.lastModifiedAt != nil {
		fields = append(fields, file.FieldLastModifiedAt)
	}
	if m.content != nil {
		fields = append(fields, file.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldName:
		return m.Name()
	case file.FieldSize:
		return m.Size()
	case file.FieldHash:
		return m.Hash()
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldLastModifiedAt:
		return m.LastModifiedAt()
	case file.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldHash:
		return m.OldHash(ctx)
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldLastModifiedAt:
		return m.OldLastModifiedAt(ctx)
	case file.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldLastModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedAt(v)
		return nil
	case file.FieldContent:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldHash:
		m.ResetHash()
		return nil
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldLastModifiedAt:
		m.ResetLastModifiedAt()
		return nil
	case file.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.deploymentConfigs != nil {
		edges = append(edges, file.EdgeDeploymentConfigs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeDeploymentConfigs:
		ids := make([]ent.Value, 0, len(m.deploymentConfigs))
		for id := range m.deploymentConfigs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddeploymentConfigs != nil {
		edges = append(edges, file.EdgeDeploymentConfigs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeDeploymentConfigs:
		ids := make([]ent.Value, 0, len(m.removeddeploymentConfigs))
		for id := range m.removeddeploymentConfigs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddeploymentConfigs {
		edges = append(edges, file.EdgeDeploymentConfigs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeDeploymentConfigs:
		return m.cleareddeploymentConfigs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeDeploymentConfigs:
		m.ResetDeploymentConfigs()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// ImplantMutation represents an operation that mutates the Implant nodes in the graph.
type ImplantMutation struct {
	config
	op             Op
	typ            string
	id             *int
	sessionID      *string
	processName    *string
	clearedFields  map[string]struct{}
	target         *int
	clearedtarget  bool
	_config        *int
	cleared_config bool
	done           bool
	oldValue       func(context.Context) (*Implant, error)
	predicates     []predicate.Implant
}

var _ ent.Mutation = (*ImplantMutation)(nil)

// implantOption allows management of the mutation configuration using functional options.
type implantOption func(*ImplantMutation)

// newImplantMutation creates new mutation for the Implant entity.
func newImplantMutation(c config, op Op, opts ...implantOption) *ImplantMutation {
	m := &ImplantMutation{
		config:        c,
		op:            op,
		typ:           TypeImplant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImplantID sets the ID field of the mutation.
func withImplantID(id int) implantOption {
	return func(m *ImplantMutation) {
		var (
			err   error
			once  sync.Once
			value *Implant
		)
		m.oldValue = func(ctx context.Context) (*Implant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Implant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImplant sets the old Implant of the mutation.
func withImplant(node *Implant) implantOption {
	return func(m *ImplantMutation) {
		m.oldValue = func(context.Context) (*Implant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImplantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImplantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImplantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImplantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Implant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSessionID sets the "sessionID" field.
func (m *ImplantMutation) SetSessionID(s string) {
	m.sessionID = &s
}

// SessionID returns the value of the "sessionID" field in the mutation.
func (m *ImplantMutation) SessionID() (r string, exists bool) {
	v := m.sessionID
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "sessionID" field's value of the Implant entity.
// If the Implant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImplantMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "sessionID" field.
func (m *ImplantMutation) ResetSessionID() {
	m.sessionID = nil
}

// SetProcessName sets the "processName" field.
func (m *ImplantMutation) SetProcessName(s string) {
	m.processName = &s
}

// ProcessName returns the value of the "processName" field in the mutation.
func (m *ImplantMutation) ProcessName() (r string, exists bool) {
	v := m.processName
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessName returns the old "processName" field's value of the Implant entity.
// If the Implant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImplantMutation) OldProcessName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessName: %w", err)
	}
	return oldValue.ProcessName, nil
}

// ClearProcessName clears the value of the "processName" field.
func (m *ImplantMutation) ClearProcessName() {
	m.processName = nil
	m.clearedFields[implant.FieldProcessName] = struct{}{}
}

// ProcessNameCleared returns if the "processName" field was cleared in this mutation.
func (m *ImplantMutation) ProcessNameCleared() bool {
	_, ok := m.clearedFields[implant.FieldProcessName]
	return ok
}

// ResetProcessName resets all changes to the "processName" field.
func (m *ImplantMutation) ResetProcessName() {
	m.processName = nil
	delete(m.clearedFields, implant.FieldProcessName)
}

// SetTargetID sets the "target" edge to the Target entity by id.
func (m *ImplantMutation) SetTargetID(id int) {
	m.target = &id
}

// ClearTarget clears the "target" edge to the Target entity.
func (m *ImplantMutation) ClearTarget() {
	m.clearedtarget = true
}

// TargetCleared reports if the "target" edge to the Target entity was cleared.
func (m *ImplantMutation) TargetCleared() bool {
	return m.clearedtarget
}

// TargetID returns the "target" edge ID in the mutation.
func (m *ImplantMutation) TargetID() (id int, exists bool) {
	if m.target != nil {
		return *m.target, true
	}
	return
}

// TargetIDs returns the "target" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetID instead. It exists only for internal usage by the builders.
func (m *ImplantMutation) TargetIDs() (ids []int) {
	if id := m.target; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTarget resets all changes to the "target" edge.
func (m *ImplantMutation) ResetTarget() {
	m.target = nil
	m.clearedtarget = false
}

// SetConfigID sets the "config" edge to the ImplantConfig entity by id.
func (m *ImplantMutation) SetConfigID(id int) {
	m._config = &id
}

// ClearConfig clears the "config" edge to the ImplantConfig entity.
func (m *ImplantMutation) ClearConfig() {
	m.cleared_config = true
}

// ConfigCleared reports if the "config" edge to the ImplantConfig entity was cleared.
func (m *ImplantMutation) ConfigCleared() bool {
	return m.cleared_config
}

// ConfigID returns the "config" edge ID in the mutation.
func (m *ImplantMutation) ConfigID() (id int, exists bool) {
	if m._config != nil {
		return *m._config, true
	}
	return
}

// ConfigIDs returns the "config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConfigID instead. It exists only for internal usage by the builders.
func (m *ImplantMutation) ConfigIDs() (ids []int) {
	if id := m._config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConfig resets all changes to the "config" edge.
func (m *ImplantMutation) ResetConfig() {
	m._config = nil
	m.cleared_config = false
}

// Where appends a list predicates to the ImplantMutation builder.
func (m *ImplantMutation) Where(ps ...predicate.Implant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ImplantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Implant).
func (m *ImplantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImplantMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.sessionID != nil {
		fields = append(fields, implant.FieldSessionID)
	}
	if m.processName != nil {
		fields = append(fields, implant.FieldProcessName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImplantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case implant.FieldSessionID:
		return m.SessionID()
	case implant.FieldProcessName:
		return m.ProcessName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImplantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case implant.FieldSessionID:
		return m.OldSessionID(ctx)
	case implant.FieldProcessName:
		return m.OldProcessName(ctx)
	}
	return nil, fmt.Errorf("unknown Implant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImplantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case implant.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case implant.FieldProcessName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessName(v)
		return nil
	}
	return fmt.Errorf("unknown Implant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImplantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImplantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImplantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Implant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImplantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(implant.FieldProcessName) {
		fields = append(fields, implant.FieldProcessName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImplantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImplantMutation) ClearField(name string) error {
	switch name {
	case implant.FieldProcessName:
		m.ClearProcessName()
		return nil
	}
	return fmt.Errorf("unknown Implant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImplantMutation) ResetField(name string) error {
	switch name {
	case implant.FieldSessionID:
		m.ResetSessionID()
		return nil
	case implant.FieldProcessName:
		m.ResetProcessName()
		return nil
	}
	return fmt.Errorf("unknown Implant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImplantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.target != nil {
		edges = append(edges, implant.EdgeTarget)
	}
	if m._config != nil {
		edges = append(edges, implant.EdgeConfig)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImplantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case implant.EdgeTarget:
		if id := m.target; id != nil {
			return []ent.Value{*id}
		}
	case implant.EdgeConfig:
		if id := m._config; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImplantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImplantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImplantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtarget {
		edges = append(edges, implant.EdgeTarget)
	}
	if m.cleared_config {
		edges = append(edges, implant.EdgeConfig)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImplantMutation) EdgeCleared(name string) bool {
	switch name {
	case implant.EdgeTarget:
		return m.clearedtarget
	case implant.EdgeConfig:
		return m.cleared_config
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImplantMutation) ClearEdge(name string) error {
	switch name {
	case implant.EdgeTarget:
		m.ClearTarget()
		return nil
	case implant.EdgeConfig:
		m.ClearConfig()
		return nil
	}
	return fmt.Errorf("unknown Implant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImplantMutation) ResetEdge(name string) error {
	switch name {
	case implant.EdgeTarget:
		m.ResetTarget()
		return nil
	case implant.EdgeConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown Implant edge %s", name)
}

// ImplantCallbackConfigMutation represents an operation that mutates the ImplantCallbackConfig nodes in the graph.
type ImplantCallbackConfigMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	uri                   *string
	proxyURI              *string
	priority              *int
	addpriority           *int
	timeout               *int
	addtimeout            *int
	interval              *int
	addinterval           *int
	jitter                *int
	addjitter             *int
	clearedFields         map[string]struct{}
	implantConfigs        map[int]struct{}
	removedimplantConfigs map[int]struct{}
	clearedimplantConfigs bool
	done                  bool
	oldValue              func(context.Context) (*ImplantCallbackConfig, error)
	predicates            []predicate.ImplantCallbackConfig
}

var _ ent.Mutation = (*ImplantCallbackConfigMutation)(nil)

// implantcallbackconfigOption allows management of the mutation configuration using functional options.
type implantcallbackconfigOption func(*ImplantCallbackConfigMutation)

// newImplantCallbackConfigMutation creates new mutation for the ImplantCallbackConfig entity.
func newImplantCallbackConfigMutation(c config, op Op, opts ...implantcallbackconfigOption) *ImplantCallbackConfigMutation {
	m := &ImplantCallbackConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeImplantCallbackConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImplantCallbackConfigID sets the ID field of the mutation.
func withImplantCallbackConfigID(id int) implantcallbackconfigOption {
	return func(m *ImplantCallbackConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *ImplantCallbackConfig
		)
		m.oldValue = func(ctx context.Context) (*ImplantCallbackConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImplantCallbackConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImplantCallbackConfig sets the old ImplantCallbackConfig of the mutation.
func withImplantCallbackConfig(node *ImplantCallbackConfig) implantcallbackconfigOption {
	return func(m *ImplantCallbackConfigMutation) {
		m.oldValue = func(context.Context) (*ImplantCallbackConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImplantCallbackConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImplantCallbackConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImplantCallbackConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImplantCallbackConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImplantCallbackConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURI sets the "uri" field.
func (m *ImplantCallbackConfigMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *ImplantCallbackConfigMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the ImplantCallbackConfig entity.
// If the ImplantCallbackConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImplantCallbackConfigMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *ImplantCallbackConfigMutation) ResetURI() {
	m.uri = nil
}

// SetProxyURI sets the "proxyURI" field.
func (m *ImplantCallbackConfigMutation) SetProxyURI(s string) {
	m.proxyURI = &s
}

// ProxyURI returns the value of the "proxyURI" field in the mutation.
func (m *ImplantCallbackConfigMutation) ProxyURI() (r string, exists bool) {
	v := m.proxyURI
	if v == nil {
		return
	}
	return *v, true
}

// OldProxyURI returns the old "proxyURI" field's value of the ImplantCallbackConfig entity.
// If the ImplantCallbackConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImplantCallbackConfigMutation) OldProxyURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProxyURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProxyURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProxyURI: %w", err)
	}
	return oldValue.ProxyURI, nil
}

// ClearProxyURI clears the value of the "proxyURI" field.
func (m *ImplantCallbackConfigMutation) ClearProxyURI() {
	m.proxyURI = nil
	m.clearedFields[implantcallbackconfig.FieldProxyURI] = struct{}{}
}

// ProxyURICleared returns if the "proxyURI" field was cleared in this mutation.
func (m *ImplantCallbackConfigMutation) ProxyURICleared() bool {
	_, ok := m.clearedFields[implantcallbackconfig.FieldProxyURI]
	return ok
}

// ResetProxyURI resets all changes to the "proxyURI" field.
func (m *ImplantCallbackConfigMutation) ResetProxyURI() {
	m.proxyURI = nil
	delete(m.clearedFields, implantcallbackconfig.FieldProxyURI)
}

// SetPriority sets the "priority" field.
func (m *ImplantCallbackConfigMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ImplantCallbackConfigMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the ImplantCallbackConfig entity.
// If the ImplantCallbackConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImplantCallbackConfigMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *ImplantCallbackConfigMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *ImplantCallbackConfigMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *ImplantCallbackConfigMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetTimeout sets the "timeout" field.
func (m *ImplantCallbackConfigMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *ImplantCallbackConfigMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the ImplantCallbackConfig entity.
// If the ImplantCallbackConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImplantCallbackConfigMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *ImplantCallbackConfigMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *ImplantCallbackConfigMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *ImplantCallbackConfigMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetInterval sets the "interval" field.
func (m *ImplantCallbackConfigMutation) SetInterval(i int) {
	m.interval = &i
	m.addinterval = nil
}

// Interval returns the value of the "interval" field in the mutation.
func (m *ImplantCallbackConfigMutation) Interval() (r int, exists bool) {
	v := m.interval
	if v == nil {
		return
	}
	return *v, true
}

// OldInterval returns the old "interval" field's value of the ImplantCallbackConfig entity.
// If the ImplantCallbackConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImplantCallbackConfigMutation) OldInterval(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterval: %w", err)
	}
	return oldValue.Interval, nil
}

// AddInterval adds i to the "interval" field.
func (m *ImplantCallbackConfigMutation) AddInterval(i int) {
	if m.addinterval != nil {
		*m.addinterval += i
	} else {
		m.addinterval = &i
	}
}

// AddedInterval returns the value that was added to the "interval" field in this mutation.
func (m *ImplantCallbackConfigMutation) AddedInterval() (r int, exists bool) {
	v := m.addinterval
	if v == nil {
		return
	}
	return *v, true
}

// ResetInterval resets all changes to the "interval" field.
func (m *ImplantCallbackConfigMutation) ResetInterval() {
	m.interval = nil
	m.addinterval = nil
}

// SetJitter sets the "jitter" field.
func (m *ImplantCallbackConfigMutation) SetJitter(i int) {
	m.jitter = &i
	m.addjitter = nil
}

// Jitter returns the value of the "jitter" field in the mutation.
func (m *ImplantCallbackConfigMutation) Jitter() (r int, exists bool) {
	v := m.jitter
	if v == nil {
		return
	}
	return *v, true
}

// OldJitter returns the old "jitter" field's value of the ImplantCallbackConfig entity.
// If the ImplantCallbackConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImplantCallbackConfigMutation) OldJitter(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJitter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJitter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJitter: %w", err)
	}
	return oldValue.Jitter, nil
}

// AddJitter adds i to the "jitter" field.
func (m *ImplantCallbackConfigMutation) AddJitter(i int) {
	if m.addjitter != nil {
		*m.addjitter += i
	} else {
		m.addjitter = &i
	}
}

// AddedJitter returns the value that was added to the "jitter" field in this mutation.
func (m *ImplantCallbackConfigMutation) AddedJitter() (r int, exists bool) {
	v := m.addjitter
	if v == nil {
		return
	}
	return *v, true
}

// ResetJitter resets all changes to the "jitter" field.
func (m *ImplantCallbackConfigMutation) ResetJitter() {
	m.jitter = nil
	m.addjitter = nil
}

// AddImplantConfigIDs adds the "implantConfigs" edge to the ImplantConfig entity by ids.
func (m *ImplantCallbackConfigMutation) AddImplantConfigIDs(ids ...int) {
	if m.implantConfigs == nil {
		m.implantConfigs = make(map[int]struct{})
	}
	for i := range ids {
		m.implantConfigs[ids[i]] = struct{}{}
	}
}

// ClearImplantConfigs clears the "implantConfigs" edge to the ImplantConfig entity.
func (m *ImplantCallbackConfigMutation) ClearImplantConfigs() {
	m.clearedimplantConfigs = true
}

// ImplantConfigsCleared reports if the "implantConfigs" edge to the ImplantConfig entity was cleared.
func (m *ImplantCallbackConfigMutation) ImplantConfigsCleared() bool {
	return m.clearedimplantConfigs
}

// RemoveImplantConfigIDs removes the "implantConfigs" edge to the ImplantConfig entity by IDs.
func (m *ImplantCallbackConfigMutation) RemoveImplantConfigIDs(ids ...int) {
	if m.removedimplantConfigs == nil {
		m.removedimplantConfigs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.implantConfigs, ids[i])
		m.removedimplantConfigs[ids[i]] = struct{}{}
	}
}

// RemovedImplantConfigs returns the removed IDs of the "implantConfigs" edge to the ImplantConfig entity.
func (m *ImplantCallbackConfigMutation) RemovedImplantConfigsIDs() (ids []int) {
	for id := range m.removedimplantConfigs {
		ids = append(ids, id)
	}
	return
}

// ImplantConfigsIDs returns the "implantConfigs" edge IDs in the mutation.
func (m *ImplantCallbackConfigMutation) ImplantConfigsIDs() (ids []int) {
	for id := range m.implantConfigs {
		ids = append(ids, id)
	}
	return
}

// ResetImplantConfigs resets all changes to the "implantConfigs" edge.
func (m *ImplantCallbackConfigMutation) ResetImplantConfigs() {
	m.implantConfigs = nil
	m.clearedimplantConfigs = false
	m.removedimplantConfigs = nil
}

// Where appends a list predicates to the ImplantCallbackConfigMutation builder.
func (m *ImplantCallbackConfigMutation) Where(ps ...predicate.ImplantCallbackConfig) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ImplantCallbackConfigMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ImplantCallbackConfig).
func (m *ImplantCallbackConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImplantCallbackConfigMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uri != nil {
		fields = append(fields, implantcallbackconfig.FieldURI)
	}
	if m.proxyURI != nil {
		fields = append(fields, implantcallbackconfig.FieldProxyURI)
	}
	if m.priority != nil {
		fields = append(fields, implantcallbackconfig.FieldPriority)
	}
	if m.timeout != nil {
		fields = append(fields, implantcallbackconfig.FieldTimeout)
	}
	if m.interval != nil {
		fields = append(fields, implantcallbackconfig.FieldInterval)
	}
	if m.jitter != nil {
		fields = append(fields, implantcallbackconfig.FieldJitter)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImplantCallbackConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case implantcallbackconfig.FieldURI:
		return m.URI()
	case implantcallbackconfig.FieldProxyURI:
		return m.ProxyURI()
	case implantcallbackconfig.FieldPriority:
		return m.Priority()
	case implantcallbackconfig.FieldTimeout:
		return m.Timeout()
	case implantcallbackconfig.FieldInterval:
		return m.Interval()
	case implantcallbackconfig.FieldJitter:
		return m.Jitter()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImplantCallbackConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case implantcallbackconfig.FieldURI:
		return m.OldURI(ctx)
	case implantcallbackconfig.FieldProxyURI:
		return m.OldProxyURI(ctx)
	case implantcallbackconfig.FieldPriority:
		return m.OldPriority(ctx)
	case implantcallbackconfig.FieldTimeout:
		return m.OldTimeout(ctx)
	case implantcallbackconfig.FieldInterval:
		return m.OldInterval(ctx)
	case implantcallbackconfig.FieldJitter:
		return m.OldJitter(ctx)
	}
	return nil, fmt.Errorf("unknown ImplantCallbackConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImplantCallbackConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case implantcallbackconfig.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case implantcallbackconfig.FieldProxyURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProxyURI(v)
		return nil
	case implantcallbackconfig.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case implantcallbackconfig.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case implantcallbackconfig.FieldInterval:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterval(v)
		return nil
	case implantcallbackconfig.FieldJitter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJitter(v)
		return nil
	}
	return fmt.Errorf("unknown ImplantCallbackConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImplantCallbackConfigMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, implantcallbackconfig.FieldPriority)
	}
	if m.addtimeout != nil {
		fields = append(fields, implantcallbackconfig.FieldTimeout)
	}
	if m.addinterval != nil {
		fields = append(fields, implantcallbackconfig.FieldInterval)
	}
	if m.addjitter != nil {
		fields = append(fields, implantcallbackconfig.FieldJitter)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImplantCallbackConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case implantcallbackconfig.FieldPriority:
		return m.AddedPriority()
	case implantcallbackconfig.FieldTimeout:
		return m.AddedTimeout()
	case implantcallbackconfig.FieldInterval:
		return m.AddedInterval()
	case implantcallbackconfig.FieldJitter:
		return m.AddedJitter()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImplantCallbackConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case implantcallbackconfig.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case implantcallbackconfig.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	case implantcallbackconfig.FieldInterval:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInterval(v)
		return nil
	case implantcallbackconfig.FieldJitter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJitter(v)
		return nil
	}
	return fmt.Errorf("unknown ImplantCallbackConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImplantCallbackConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(implantcallbackconfig.FieldProxyURI) {
		fields = append(fields, implantcallbackconfig.FieldProxyURI)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImplantCallbackConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImplantCallbackConfigMutation) ClearField(name string) error {
	switch name {
	case implantcallbackconfig.FieldProxyURI:
		m.ClearProxyURI()
		return nil
	}
	return fmt.Errorf("unknown ImplantCallbackConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImplantCallbackConfigMutation) ResetField(name string) error {
	switch name {
	case implantcallbackconfig.FieldURI:
		m.ResetURI()
		return nil
	case implantcallbackconfig.FieldProxyURI:
		m.ResetProxyURI()
		return nil
	case implantcallbackconfig.FieldPriority:
		m.ResetPriority()
		return nil
	case implantcallbackconfig.FieldTimeout:
		m.ResetTimeout()
		return nil
	case implantcallbackconfig.FieldInterval:
		m.ResetInterval()
		return nil
	case implantcallbackconfig.FieldJitter:
		m.ResetJitter()
		return nil
	}
	return fmt.Errorf("unknown ImplantCallbackConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImplantCallbackConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.implantConfigs != nil {
		edges = append(edges, implantcallbackconfig.EdgeImplantConfigs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImplantCallbackConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case implantcallbackconfig.EdgeImplantConfigs:
		ids := make([]ent.Value, 0, len(m.implantConfigs))
		for id := range m.implantConfigs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImplantCallbackConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedimplantConfigs != nil {
		edges = append(edges, implantcallbackconfig.EdgeImplantConfigs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImplantCallbackConfigMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case implantcallbackconfig.EdgeImplantConfigs:
		ids := make([]ent.Value, 0, len(m.removedimplantConfigs))
		for id := range m.removedimplantConfigs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImplantCallbackConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedimplantConfigs {
		edges = append(edges, implantcallbackconfig.EdgeImplantConfigs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImplantCallbackConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case implantcallbackconfig.EdgeImplantConfigs:
		return m.clearedimplantConfigs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImplantCallbackConfigMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ImplantCallbackConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImplantCallbackConfigMutation) ResetEdge(name string) error {
	switch name {
	case implantcallbackconfig.EdgeImplantConfigs:
		m.ResetImplantConfigs()
		return nil
	}
	return fmt.Errorf("unknown ImplantCallbackConfig edge %s", name)
}

// ImplantConfigMutation represents an operation that mutates the ImplantConfig nodes in the graph.
type ImplantConfigMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *string
	authToken                *string
	clearedFields            map[string]struct{}
	deploymentConfigs        map[int]struct{}
	removeddeploymentConfigs map[int]struct{}
	cleareddeploymentConfigs bool
	implants                 map[int]struct{}
	removedimplants          map[int]struct{}
	clearedimplants          bool
	serviceConfigs           map[int]struct{}
	removedserviceConfigs    map[int]struct{}
	clearedserviceConfigs    bool
	callbackConfigs          map[int]struct{}
	removedcallbackConfigs   map[int]struct{}
	clearedcallbackConfigs   bool
	done                     bool
	oldValue                 func(context.Context) (*ImplantConfig, error)
	predicates               []predicate.ImplantConfig
}

var _ ent.Mutation = (*ImplantConfigMutation)(nil)

// implantconfigOption allows management of the mutation configuration using functional options.
type implantconfigOption func(*ImplantConfigMutation)

// newImplantConfigMutation creates new mutation for the ImplantConfig entity.
func newImplantConfigMutation(c config, op Op, opts ...implantconfigOption) *ImplantConfigMutation {
	m := &ImplantConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeImplantConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImplantConfigID sets the ID field of the mutation.
func withImplantConfigID(id int) implantconfigOption {
	return func(m *ImplantConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *ImplantConfig
		)
		m.oldValue = func(ctx context.Context) (*ImplantConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImplantConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImplantConfig sets the old ImplantConfig of the mutation.
func withImplantConfig(node *ImplantConfig) implantconfigOption {
	return func(m *ImplantConfigMutation) {
		m.oldValue = func(context.Context) (*ImplantConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImplantConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImplantConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImplantConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImplantConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImplantConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ImplantConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ImplantConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ImplantConfig entity.
// If the ImplantConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImplantConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ImplantConfigMutation) ResetName() {
	m.name = nil
}

// SetAuthToken sets the "authToken" field.
func (m *ImplantConfigMutation) SetAuthToken(s string) {
	m.authToken = &s
}

// AuthToken returns the value of the "authToken" field in the mutation.
func (m *ImplantConfigMutation) AuthToken() (r string, exists bool) {
	v := m.authToken
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthToken returns the old "authToken" field's value of the ImplantConfig entity.
// If the ImplantConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImplantConfigMutation) OldAuthToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthToken: %w", err)
	}
	return oldValue.AuthToken, nil
}

// ResetAuthToken resets all changes to the "authToken" field.
func (m *ImplantConfigMutation) ResetAuthToken() {
	m.authToken = nil
}

// AddDeploymentConfigIDs adds the "deploymentConfigs" edge to the DeploymentConfig entity by ids.
func (m *ImplantConfigMutation) AddDeploymentConfigIDs(ids ...int) {
	if m.deploymentConfigs == nil {
		m.deploymentConfigs = make(map[int]struct{})
	}
	for i := range ids {
		m.deploymentConfigs[ids[i]] = struct{}{}
	}
}

// ClearDeploymentConfigs clears the "deploymentConfigs" edge to the DeploymentConfig entity.
func (m *ImplantConfigMutation) ClearDeploymentConfigs() {
	m.cleareddeploymentConfigs = true
}

// DeploymentConfigsCleared reports if the "deploymentConfigs" edge to the DeploymentConfig entity was cleared.
func (m *ImplantConfigMutation) DeploymentConfigsCleared() bool {
	return m.cleareddeploymentConfigs
}

// RemoveDeploymentConfigIDs removes the "deploymentConfigs" edge to the DeploymentConfig entity by IDs.
func (m *ImplantConfigMutation) RemoveDeploymentConfigIDs(ids ...int) {
	if m.removeddeploymentConfigs == nil {
		m.removeddeploymentConfigs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.deploymentConfigs, ids[i])
		m.removeddeploymentConfigs[ids[i]] = struct{}{}
	}
}

// RemovedDeploymentConfigs returns the removed IDs of the "deploymentConfigs" edge to the DeploymentConfig entity.
func (m *ImplantConfigMutation) RemovedDeploymentConfigsIDs() (ids []int) {
	for id := range m.removeddeploymentConfigs {
		ids = append(ids, id)
	}
	return
}

// DeploymentConfigsIDs returns the "deploymentConfigs" edge IDs in the mutation.
func (m *ImplantConfigMutation) DeploymentConfigsIDs() (ids []int) {
	for id := range m.deploymentConfigs {
		ids = append(ids, id)
	}
	return
}

// ResetDeploymentConfigs resets all changes to the "deploymentConfigs" edge.
func (m *ImplantConfigMutation) ResetDeploymentConfigs() {
	m.deploymentConfigs = nil
	m.cleareddeploymentConfigs = false
	m.removeddeploymentConfigs = nil
}

// AddImplantIDs adds the "implants" edge to the Implant entity by ids.
func (m *ImplantConfigMutation) AddImplantIDs(ids ...int) {
	if m.implants == nil {
		m.implants = make(map[int]struct{})
	}
	for i := range ids {
		m.implants[ids[i]] = struct{}{}
	}
}

// ClearImplants clears the "implants" edge to the Implant entity.
func (m *ImplantConfigMutation) ClearImplants() {
	m.clearedimplants = true
}

// ImplantsCleared reports if the "implants" edge to the Implant entity was cleared.
func (m *ImplantConfigMutation) ImplantsCleared() bool {
	return m.clearedimplants
}

// RemoveImplantIDs removes the "implants" edge to the Implant entity by IDs.
func (m *ImplantConfigMutation) RemoveImplantIDs(ids ...int) {
	if m.removedimplants == nil {
		m.removedimplants = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.implants, ids[i])
		m.removedimplants[ids[i]] = struct{}{}
	}
}

// RemovedImplants returns the removed IDs of the "implants" edge to the Implant entity.
func (m *ImplantConfigMutation) RemovedImplantsIDs() (ids []int) {
	for id := range m.removedimplants {
		ids = append(ids, id)
	}
	return
}

// ImplantsIDs returns the "implants" edge IDs in the mutation.
func (m *ImplantConfigMutation) ImplantsIDs() (ids []int) {
	for id := range m.implants {
		ids = append(ids, id)
	}
	return
}

// ResetImplants resets all changes to the "implants" edge.
func (m *ImplantConfigMutation) ResetImplants() {
	m.implants = nil
	m.clearedimplants = false
	m.removedimplants = nil
}

// AddServiceConfigIDs adds the "serviceConfigs" edge to the ImplantServiceConfig entity by ids.
func (m *ImplantConfigMutation) AddServiceConfigIDs(ids ...int) {
	if m.serviceConfigs == nil {
		m.serviceConfigs = make(map[int]struct{})
	}
	for i := range ids {
		m.serviceConfigs[ids[i]] = struct{}{}
	}
}

// ClearServiceConfigs clears the "serviceConfigs" edge to the ImplantServiceConfig entity.
func (m *ImplantConfigMutation) ClearServiceConfigs() {
	m.clearedserviceConfigs = true
}

// ServiceConfigsCleared reports if the "serviceConfigs" edge to the ImplantServiceConfig entity was cleared.
func (m *ImplantConfigMutation) ServiceConfigsCleared() bool {
	return m.clearedserviceConfigs
}

// RemoveServiceConfigIDs removes the "serviceConfigs" edge to the ImplantServiceConfig entity by IDs.
func (m *ImplantConfigMutation) RemoveServiceConfigIDs(ids ...int) {
	if m.removedserviceConfigs == nil {
		m.removedserviceConfigs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.serviceConfigs, ids[i])
		m.removedserviceConfigs[ids[i]] = struct{}{}
	}
}

// RemovedServiceConfigs returns the removed IDs of the "serviceConfigs" edge to the ImplantServiceConfig entity.
func (m *ImplantConfigMutation) RemovedServiceConfigsIDs() (ids []int) {
	for id := range m.removedserviceConfigs {
		ids = append(ids, id)
	}
	return
}

// ServiceConfigsIDs returns the "serviceConfigs" edge IDs in the mutation.
func (m *ImplantConfigMutation) ServiceConfigsIDs() (ids []int) {
	for id := range m.serviceConfigs {
		ids = append(ids, id)
	}
	return
}

// ResetServiceConfigs resets all changes to the "serviceConfigs" edge.
func (m *ImplantConfigMutation) ResetServiceConfigs() {
	m.serviceConfigs = nil
	m.clearedserviceConfigs = false
	m.removedserviceConfigs = nil
}

// AddCallbackConfigIDs adds the "callbackConfigs" edge to the ImplantCallbackConfig entity by ids.
func (m *ImplantConfigMutation) AddCallbackConfigIDs(ids ...int) {
	if m.callbackConfigs == nil {
		m.callbackConfigs = make(map[int]struct{})
	}
	for i := range ids {
		m.callbackConfigs[ids[i]] = struct{}{}
	}
}

// ClearCallbackConfigs clears the "callbackConfigs" edge to the ImplantCallbackConfig entity.
func (m *ImplantConfigMutation) ClearCallbackConfigs() {
	m.clearedcallbackConfigs = true
}

// CallbackConfigsCleared reports if the "callbackConfigs" edge to the ImplantCallbackConfig entity was cleared.
func (m *ImplantConfigMutation) CallbackConfigsCleared() bool {
	return m.clearedcallbackConfigs
}

// RemoveCallbackConfigIDs removes the "callbackConfigs" edge to the ImplantCallbackConfig entity by IDs.
func (m *ImplantConfigMutation) RemoveCallbackConfigIDs(ids ...int) {
	if m.removedcallbackConfigs == nil {
		m.removedcallbackConfigs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.callbackConfigs, ids[i])
		m.removedcallbackConfigs[ids[i]] = struct{}{}
	}
}

// RemovedCallbackConfigs returns the removed IDs of the "callbackConfigs" edge to the ImplantCallbackConfig entity.
func (m *ImplantConfigMutation) RemovedCallbackConfigsIDs() (ids []int) {
	for id := range m.removedcallbackConfigs {
		ids = append(ids, id)
	}
	return
}

// CallbackConfigsIDs returns the "callbackConfigs" edge IDs in the mutation.
func (m *ImplantConfigMutation) CallbackConfigsIDs() (ids []int) {
	for id := range m.callbackConfigs {
		ids = append(ids, id)
	}
	return
}

// ResetCallbackConfigs resets all changes to the "callbackConfigs" edge.
func (m *ImplantConfigMutation) ResetCallbackConfigs() {
	m.callbackConfigs = nil
	m.clearedcallbackConfigs = false
	m.removedcallbackConfigs = nil
}

// Where appends a list predicates to the ImplantConfigMutation builder.
func (m *ImplantConfigMutation) Where(ps ...predicate.ImplantConfig) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ImplantConfigMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ImplantConfig).
func (m *ImplantConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImplantConfigMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, implantconfig.FieldName)
	}
	if m.authToken != nil {
		fields = append(fields, implantconfig.FieldAuthToken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImplantConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case implantconfig.FieldName:
		return m.Name()
	case implantconfig.FieldAuthToken:
		return m.AuthToken()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImplantConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case implantconfig.FieldName:
		return m.OldName(ctx)
	case implantconfig.FieldAuthToken:
		return m.OldAuthToken(ctx)
	}
	return nil, fmt.Errorf("unknown ImplantConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImplantConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case implantconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case implantconfig.FieldAuthToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthToken(v)
		return nil
	}
	return fmt.Errorf("unknown ImplantConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImplantConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImplantConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImplantConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ImplantConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImplantConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImplantConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImplantConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ImplantConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImplantConfigMutation) ResetField(name string) error {
	switch name {
	case implantconfig.FieldName:
		m.ResetName()
		return nil
	case implantconfig.FieldAuthToken:
		m.ResetAuthToken()
		return nil
	}
	return fmt.Errorf("unknown ImplantConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImplantConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.deploymentConfigs != nil {
		edges = append(edges, implantconfig.EdgeDeploymentConfigs)
	}
	if m.implants != nil {
		edges = append(edges, implantconfig.EdgeImplants)
	}
	if m.serviceConfigs != nil {
		edges = append(edges, implantconfig.EdgeServiceConfigs)
	}
	if m.callbackConfigs != nil {
		edges = append(edges, implantconfig.EdgeCallbackConfigs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImplantConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case implantconfig.EdgeDeploymentConfigs:
		ids := make([]ent.Value, 0, len(m.deploymentConfigs))
		for id := range m.deploymentConfigs {
			ids = append(ids, id)
		}
		return ids
	case implantconfig.EdgeImplants:
		ids := make([]ent.Value, 0, len(m.implants))
		for id := range m.implants {
			ids = append(ids, id)
		}
		return ids
	case implantconfig.EdgeServiceConfigs:
		ids := make([]ent.Value, 0, len(m.serviceConfigs))
		for id := range m.serviceConfigs {
			ids = append(ids, id)
		}
		return ids
	case implantconfig.EdgeCallbackConfigs:
		ids := make([]ent.Value, 0, len(m.callbackConfigs))
		for id := range m.callbackConfigs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImplantConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddeploymentConfigs != nil {
		edges = append(edges, implantconfig.EdgeDeploymentConfigs)
	}
	if m.removedimplants != nil {
		edges = append(edges, implantconfig.EdgeImplants)
	}
	if m.removedserviceConfigs != nil {
		edges = append(edges, implantconfig.EdgeServiceConfigs)
	}
	if m.removedcallbackConfigs != nil {
		edges = append(edges, implantconfig.EdgeCallbackConfigs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImplantConfigMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case implantconfig.EdgeDeploymentConfigs:
		ids := make([]ent.Value, 0, len(m.removeddeploymentConfigs))
		for id := range m.removeddeploymentConfigs {
			ids = append(ids, id)
		}
		return ids
	case implantconfig.EdgeImplants:
		ids := make([]ent.Value, 0, len(m.removedimplants))
		for id := range m.removedimplants {
			ids = append(ids, id)
		}
		return ids
	case implantconfig.EdgeServiceConfigs:
		ids := make([]ent.Value, 0, len(m.removedserviceConfigs))
		for id := range m.removedserviceConfigs {
			ids = append(ids, id)
		}
		return ids
	case implantconfig.EdgeCallbackConfigs:
		ids := make([]ent.Value, 0, len(m.removedcallbackConfigs))
		for id := range m.removedcallbackConfigs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImplantConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddeploymentConfigs {
		edges = append(edges, implantconfig.EdgeDeploymentConfigs)
	}
	if m.clearedimplants {
		edges = append(edges, implantconfig.EdgeImplants)
	}
	if m.clearedserviceConfigs {
		edges = append(edges, implantconfig.EdgeServiceConfigs)
	}
	if m.clearedcallbackConfigs {
		edges = append(edges, implantconfig.EdgeCallbackConfigs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImplantConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case implantconfig.EdgeDeploymentConfigs:
		return m.cleareddeploymentConfigs
	case implantconfig.EdgeImplants:
		return m.clearedimplants
	case implantconfig.EdgeServiceConfigs:
		return m.clearedserviceConfigs
	case implantconfig.EdgeCallbackConfigs:
		return m.clearedcallbackConfigs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImplantConfigMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ImplantConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImplantConfigMutation) ResetEdge(name string) error {
	switch name {
	case implantconfig.EdgeDeploymentConfigs:
		m.ResetDeploymentConfigs()
		return nil
	case implantconfig.EdgeImplants:
		m.ResetImplants()
		return nil
	case implantconfig.EdgeServiceConfigs:
		m.ResetServiceConfigs()
		return nil
	case implantconfig.EdgeCallbackConfigs:
		m.ResetCallbackConfigs()
		return nil
	}
	return fmt.Errorf("unknown ImplantConfig edge %s", name)
}

// ImplantServiceConfigMutation represents an operation that mutates the ImplantServiceConfig nodes in the graph.
type ImplantServiceConfigMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	name                  *string
	description           *string
	executablePath        *string
	clearedFields         map[string]struct{}
	implantConfigs        map[int]struct{}
	removedimplantConfigs map[int]struct{}
	clearedimplantConfigs bool
	done                  bool
	oldValue              func(context.Context) (*ImplantServiceConfig, error)
	predicates            []predicate.ImplantServiceConfig
}

var _ ent.Mutation = (*ImplantServiceConfigMutation)(nil)

// implantserviceconfigOption allows management of the mutation configuration using functional options.
type implantserviceconfigOption func(*ImplantServiceConfigMutation)

// newImplantServiceConfigMutation creates new mutation for the ImplantServiceConfig entity.
func newImplantServiceConfigMutation(c config, op Op, opts ...implantserviceconfigOption) *ImplantServiceConfigMutation {
	m := &ImplantServiceConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeImplantServiceConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImplantServiceConfigID sets the ID field of the mutation.
func withImplantServiceConfigID(id int) implantserviceconfigOption {
	return func(m *ImplantServiceConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *ImplantServiceConfig
		)
		m.oldValue = func(ctx context.Context) (*ImplantServiceConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImplantServiceConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImplantServiceConfig sets the old ImplantServiceConfig of the mutation.
func withImplantServiceConfig(node *ImplantServiceConfig) implantserviceconfigOption {
	return func(m *ImplantServiceConfigMutation) {
		m.oldValue = func(context.Context) (*ImplantServiceConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImplantServiceConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImplantServiceConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImplantServiceConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImplantServiceConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImplantServiceConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ImplantServiceConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ImplantServiceConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ImplantServiceConfig entity.
// If the ImplantServiceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImplantServiceConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ImplantServiceConfigMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ImplantServiceConfigMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ImplantServiceConfigMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ImplantServiceConfig entity.
// If the ImplantServiceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImplantServiceConfigMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ImplantServiceConfigMutation) ResetDescription() {
	m.description = nil
}

// SetExecutablePath sets the "executablePath" field.
func (m *ImplantServiceConfigMutation) SetExecutablePath(s string) {
	m.executablePath = &s
}

// ExecutablePath returns the value of the "executablePath" field in the mutation.
func (m *ImplantServiceConfigMutation) ExecutablePath() (r string, exists bool) {
	v := m.executablePath
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutablePath returns the old "executablePath" field's value of the ImplantServiceConfig entity.
// If the ImplantServiceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImplantServiceConfigMutation) OldExecutablePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutablePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutablePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutablePath: %w", err)
	}
	return oldValue.ExecutablePath, nil
}

// ResetExecutablePath resets all changes to the "executablePath" field.
func (m *ImplantServiceConfigMutation) ResetExecutablePath() {
	m.executablePath = nil
}

// AddImplantConfigIDs adds the "implantConfigs" edge to the ImplantConfig entity by ids.
func (m *ImplantServiceConfigMutation) AddImplantConfigIDs(ids ...int) {
	if m.implantConfigs == nil {
		m.implantConfigs = make(map[int]struct{})
	}
	for i := range ids {
		m.implantConfigs[ids[i]] = struct{}{}
	}
}

// ClearImplantConfigs clears the "implantConfigs" edge to the ImplantConfig entity.
func (m *ImplantServiceConfigMutation) ClearImplantConfigs() {
	m.clearedimplantConfigs = true
}

// ImplantConfigsCleared reports if the "implantConfigs" edge to the ImplantConfig entity was cleared.
func (m *ImplantServiceConfigMutation) ImplantConfigsCleared() bool {
	return m.clearedimplantConfigs
}

// RemoveImplantConfigIDs removes the "implantConfigs" edge to the ImplantConfig entity by IDs.
func (m *ImplantServiceConfigMutation) RemoveImplantConfigIDs(ids ...int) {
	if m.removedimplantConfigs == nil {
		m.removedimplantConfigs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.implantConfigs, ids[i])
		m.removedimplantConfigs[ids[i]] = struct{}{}
	}
}

// RemovedImplantConfigs returns the removed IDs of the "implantConfigs" edge to the ImplantConfig entity.
func (m *ImplantServiceConfigMutation) RemovedImplantConfigsIDs() (ids []int) {
	for id := range m.removedimplantConfigs {
		ids = append(ids, id)
	}
	return
}

// ImplantConfigsIDs returns the "implantConfigs" edge IDs in the mutation.
func (m *ImplantServiceConfigMutation) ImplantConfigsIDs() (ids []int) {
	for id := range m.implantConfigs {
		ids = append(ids, id)
	}
	return
}

// ResetImplantConfigs resets all changes to the "implantConfigs" edge.
func (m *ImplantServiceConfigMutation) ResetImplantConfigs() {
	m.implantConfigs = nil
	m.clearedimplantConfigs = false
	m.removedimplantConfigs = nil
}

// Where appends a list predicates to the ImplantServiceConfigMutation builder.
func (m *ImplantServiceConfigMutation) Where(ps ...predicate.ImplantServiceConfig) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ImplantServiceConfigMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ImplantServiceConfig).
func (m *ImplantServiceConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImplantServiceConfigMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, implantserviceconfig.FieldName)
	}
	if m.description != nil {
		fields = append(fields, implantserviceconfig.FieldDescription)
	}
	if m.executablePath != nil {
		fields = append(fields, implantserviceconfig.FieldExecutablePath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImplantServiceConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case implantserviceconfig.FieldName:
		return m.Name()
	case implantserviceconfig.FieldDescription:
		return m.Description()
	case implantserviceconfig.FieldExecutablePath:
		return m.ExecutablePath()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImplantServiceConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case implantserviceconfig.FieldName:
		return m.OldName(ctx)
	case implantserviceconfig.FieldDescription:
		return m.OldDescription(ctx)
	case implantserviceconfig.FieldExecutablePath:
		return m.OldExecutablePath(ctx)
	}
	return nil, fmt.Errorf("unknown ImplantServiceConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImplantServiceConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case implantserviceconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case implantserviceconfig.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case implantserviceconfig.FieldExecutablePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutablePath(v)
		return nil
	}
	return fmt.Errorf("unknown ImplantServiceConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImplantServiceConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImplantServiceConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImplantServiceConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ImplantServiceConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImplantServiceConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImplantServiceConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImplantServiceConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ImplantServiceConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImplantServiceConfigMutation) ResetField(name string) error {
	switch name {
	case implantserviceconfig.FieldName:
		m.ResetName()
		return nil
	case implantserviceconfig.FieldDescription:
		m.ResetDescription()
		return nil
	case implantserviceconfig.FieldExecutablePath:
		m.ResetExecutablePath()
		return nil
	}
	return fmt.Errorf("unknown ImplantServiceConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImplantServiceConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.implantConfigs != nil {
		edges = append(edges, implantserviceconfig.EdgeImplantConfigs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImplantServiceConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case implantserviceconfig.EdgeImplantConfigs:
		ids := make([]ent.Value, 0, len(m.implantConfigs))
		for id := range m.implantConfigs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImplantServiceConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedimplantConfigs != nil {
		edges = append(edges, implantserviceconfig.EdgeImplantConfigs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImplantServiceConfigMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case implantserviceconfig.EdgeImplantConfigs:
		ids := make([]ent.Value, 0, len(m.removedimplantConfigs))
		for id := range m.removedimplantConfigs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImplantServiceConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedimplantConfigs {
		edges = append(edges, implantserviceconfig.EdgeImplantConfigs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImplantServiceConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case implantserviceconfig.EdgeImplantConfigs:
		return m.clearedimplantConfigs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImplantServiceConfigMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ImplantServiceConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImplantServiceConfigMutation) ResetEdge(name string) error {
	switch name {
	case implantserviceconfig.EdgeImplantConfigs:
		m.ResetImplantConfigs()
		return nil
	}
	return fmt.Errorf("unknown ImplantServiceConfig edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	clearedFields  map[string]struct{}
	targets        map[int]struct{}
	removedtargets map[int]struct{}
	clearedtargets bool
	done           bool
	oldValue       func(context.Context) (*Tag, error)
	predicates     []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// AddTargetIDs adds the "targets" edge to the Target entity by ids.
func (m *TagMutation) AddTargetIDs(ids ...int) {
	if m.targets == nil {
		m.targets = make(map[int]struct{})
	}
	for i := range ids {
		m.targets[ids[i]] = struct{}{}
	}
}

// ClearTargets clears the "targets" edge to the Target entity.
func (m *TagMutation) ClearTargets() {
	m.clearedtargets = true
}

// TargetsCleared reports if the "targets" edge to the Target entity was cleared.
func (m *TagMutation) TargetsCleared() bool {
	return m.clearedtargets
}

// RemoveTargetIDs removes the "targets" edge to the Target entity by IDs.
func (m *TagMutation) RemoveTargetIDs(ids ...int) {
	if m.removedtargets == nil {
		m.removedtargets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.targets, ids[i])
		m.removedtargets[ids[i]] = struct{}{}
	}
}

// RemovedTargets returns the removed IDs of the "targets" edge to the Target entity.
func (m *TagMutation) RemovedTargetsIDs() (ids []int) {
	for id := range m.removedtargets {
		ids = append(ids, id)
	}
	return
}

// TargetsIDs returns the "targets" edge IDs in the mutation.
func (m *TagMutation) TargetsIDs() (ids []int) {
	for id := range m.targets {
		ids = append(ids, id)
	}
	return
}

// ResetTargets resets all changes to the "targets" edge.
func (m *TagMutation) ResetTargets() {
	m.targets = nil
	m.clearedtargets = false
	m.removedtargets = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.targets != nil {
		edges = append(edges, tag.EdgeTargets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeTargets:
		ids := make([]ent.Value, 0, len(m.targets))
		for id := range m.targets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtargets != nil {
		edges = append(edges, tag.EdgeTargets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeTargets:
		ids := make([]ent.Value, 0, len(m.removedtargets))
		for id := range m.removedtargets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtargets {
		edges = append(edges, tag.EdgeTargets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeTargets:
		return m.clearedtargets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeTargets:
		m.ResetTargets()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TargetMutation represents an operation that mutates the Target nodes in the graph.
type TargetMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	forwardConnectIP   *string
	clearedFields      map[string]struct{}
	implants           map[int]struct{}
	removedimplants    map[int]struct{}
	clearedimplants    bool
	deployments        map[int]struct{}
	removeddeployments map[int]struct{}
	cleareddeployments bool
	credentials        map[int]struct{}
	removedcredentials map[int]struct{}
	clearedcredentials bool
	tags               map[int]struct{}
	removedtags        map[int]struct{}
	clearedtags        bool
	done               bool
	oldValue           func(context.Context) (*Target, error)
	predicates         []predicate.Target
}

var _ ent.Mutation = (*TargetMutation)(nil)

// targetOption allows management of the mutation configuration using functional options.
type targetOption func(*TargetMutation)

// newTargetMutation creates new mutation for the Target entity.
func newTargetMutation(c config, op Op, opts ...targetOption) *TargetMutation {
	m := &TargetMutation{
		config:        c,
		op:            op,
		typ:           TypeTarget,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTargetID sets the ID field of the mutation.
func withTargetID(id int) targetOption {
	return func(m *TargetMutation) {
		var (
			err   error
			once  sync.Once
			value *Target
		)
		m.oldValue = func(ctx context.Context) (*Target, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Target.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTarget sets the old Target of the mutation.
func withTarget(node *Target) targetOption {
	return func(m *TargetMutation) {
		m.oldValue = func(context.Context) (*Target, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TargetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TargetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TargetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TargetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Target.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TargetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TargetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TargetMutation) ResetName() {
	m.name = nil
}

// SetForwardConnectIP sets the "forwardConnectIP" field.
func (m *TargetMutation) SetForwardConnectIP(s string) {
	m.forwardConnectIP = &s
}

// ForwardConnectIP returns the value of the "forwardConnectIP" field in the mutation.
func (m *TargetMutation) ForwardConnectIP() (r string, exists bool) {
	v := m.forwardConnectIP
	if v == nil {
		return
	}
	return *v, true
}

// OldForwardConnectIP returns the old "forwardConnectIP" field's value of the Target entity.
// If the Target object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TargetMutation) OldForwardConnectIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForwardConnectIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForwardConnectIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForwardConnectIP: %w", err)
	}
	return oldValue.ForwardConnectIP, nil
}

// ResetForwardConnectIP resets all changes to the "forwardConnectIP" field.
func (m *TargetMutation) ResetForwardConnectIP() {
	m.forwardConnectIP = nil
}

// AddImplantIDs adds the "implants" edge to the Implant entity by ids.
func (m *TargetMutation) AddImplantIDs(ids ...int) {
	if m.implants == nil {
		m.implants = make(map[int]struct{})
	}
	for i := range ids {
		m.implants[ids[i]] = struct{}{}
	}
}

// ClearImplants clears the "implants" edge to the Implant entity.
func (m *TargetMutation) ClearImplants() {
	m.clearedimplants = true
}

// ImplantsCleared reports if the "implants" edge to the Implant entity was cleared.
func (m *TargetMutation) ImplantsCleared() bool {
	return m.clearedimplants
}

// RemoveImplantIDs removes the "implants" edge to the Implant entity by IDs.
func (m *TargetMutation) RemoveImplantIDs(ids ...int) {
	if m.removedimplants == nil {
		m.removedimplants = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.implants, ids[i])
		m.removedimplants[ids[i]] = struct{}{}
	}
}

// RemovedImplants returns the removed IDs of the "implants" edge to the Implant entity.
func (m *TargetMutation) RemovedImplantsIDs() (ids []int) {
	for id := range m.removedimplants {
		ids = append(ids, id)
	}
	return
}

// ImplantsIDs returns the "implants" edge IDs in the mutation.
func (m *TargetMutation) ImplantsIDs() (ids []int) {
	for id := range m.implants {
		ids = append(ids, id)
	}
	return
}

// ResetImplants resets all changes to the "implants" edge.
func (m *TargetMutation) ResetImplants() {
	m.implants = nil
	m.clearedimplants = false
	m.removedimplants = nil
}

// AddDeploymentIDs adds the "deployments" edge to the Deployment entity by ids.
func (m *TargetMutation) AddDeploymentIDs(ids ...int) {
	if m.deployments == nil {
		m.deployments = make(map[int]struct{})
	}
	for i := range ids {
		m.deployments[ids[i]] = struct{}{}
	}
}

// ClearDeployments clears the "deployments" edge to the Deployment entity.
func (m *TargetMutation) ClearDeployments() {
	m.cleareddeployments = true
}

// DeploymentsCleared reports if the "deployments" edge to the Deployment entity was cleared.
func (m *TargetMutation) DeploymentsCleared() bool {
	return m.cleareddeployments
}

// RemoveDeploymentIDs removes the "deployments" edge to the Deployment entity by IDs.
func (m *TargetMutation) RemoveDeploymentIDs(ids ...int) {
	if m.removeddeployments == nil {
		m.removeddeployments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.deployments, ids[i])
		m.removeddeployments[ids[i]] = struct{}{}
	}
}

// RemovedDeployments returns the removed IDs of the "deployments" edge to the Deployment entity.
func (m *TargetMutation) RemovedDeploymentsIDs() (ids []int) {
	for id := range m.removeddeployments {
		ids = append(ids, id)
	}
	return
}

// DeploymentsIDs returns the "deployments" edge IDs in the mutation.
func (m *TargetMutation) DeploymentsIDs() (ids []int) {
	for id := range m.deployments {
		ids = append(ids, id)
	}
	return
}

// ResetDeployments resets all changes to the "deployments" edge.
func (m *TargetMutation) ResetDeployments() {
	m.deployments = nil
	m.cleareddeployments = false
	m.removeddeployments = nil
}

// AddCredentialIDs adds the "credentials" edge to the Credential entity by ids.
func (m *TargetMutation) AddCredentialIDs(ids ...int) {
	if m.credentials == nil {
		m.credentials = make(map[int]struct{})
	}
	for i := range ids {
		m.credentials[ids[i]] = struct{}{}
	}
}

// ClearCredentials clears the "credentials" edge to the Credential entity.
func (m *TargetMutation) ClearCredentials() {
	m.clearedcredentials = true
}

// CredentialsCleared reports if the "credentials" edge to the Credential entity was cleared.
func (m *TargetMutation) CredentialsCleared() bool {
	return m.clearedcredentials
}

// RemoveCredentialIDs removes the "credentials" edge to the Credential entity by IDs.
func (m *TargetMutation) RemoveCredentialIDs(ids ...int) {
	if m.removedcredentials == nil {
		m.removedcredentials = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.credentials, ids[i])
		m.removedcredentials[ids[i]] = struct{}{}
	}
}

// RemovedCredentials returns the removed IDs of the "credentials" edge to the Credential entity.
func (m *TargetMutation) RemovedCredentialsIDs() (ids []int) {
	for id := range m.removedcredentials {
		ids = append(ids, id)
	}
	return
}

// CredentialsIDs returns the "credentials" edge IDs in the mutation.
func (m *TargetMutation) CredentialsIDs() (ids []int) {
	for id := range m.credentials {
		ids = append(ids, id)
	}
	return
}

// ResetCredentials resets all changes to the "credentials" edge.
func (m *TargetMutation) ResetCredentials() {
	m.credentials = nil
	m.clearedcredentials = false
	m.removedcredentials = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *TargetMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *TargetMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *TargetMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *TargetMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *TargetMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *TargetMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *TargetMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the TargetMutation builder.
func (m *TargetMutation) Where(ps ...predicate.Target) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TargetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Target).
func (m *TargetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TargetMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, target.FieldName)
	}
	if m.forwardConnectIP != nil {
		fields = append(fields, target.FieldForwardConnectIP)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TargetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case target.FieldName:
		return m.Name()
	case target.FieldForwardConnectIP:
		return m.ForwardConnectIP()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TargetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case target.FieldName:
		return m.OldName(ctx)
	case target.FieldForwardConnectIP:
		return m.OldForwardConnectIP(ctx)
	}
	return nil, fmt.Errorf("unknown Target field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TargetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case target.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case target.FieldForwardConnectIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForwardConnectIP(v)
		return nil
	}
	return fmt.Errorf("unknown Target field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TargetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TargetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TargetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Target numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TargetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TargetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TargetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Target nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TargetMutation) ResetField(name string) error {
	switch name {
	case target.FieldName:
		m.ResetName()
		return nil
	case target.FieldForwardConnectIP:
		m.ResetForwardConnectIP()
		return nil
	}
	return fmt.Errorf("unknown Target field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TargetMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.implants != nil {
		edges = append(edges, target.EdgeImplants)
	}
	if m.deployments != nil {
		edges = append(edges, target.EdgeDeployments)
	}
	if m.credentials != nil {
		edges = append(edges, target.EdgeCredentials)
	}
	if m.tags != nil {
		edges = append(edges, target.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TargetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case target.EdgeImplants:
		ids := make([]ent.Value, 0, len(m.implants))
		for id := range m.implants {
			ids = append(ids, id)
		}
		return ids
	case target.EdgeDeployments:
		ids := make([]ent.Value, 0, len(m.deployments))
		for id := range m.deployments {
			ids = append(ids, id)
		}
		return ids
	case target.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.credentials))
		for id := range m.credentials {
			ids = append(ids, id)
		}
		return ids
	case target.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TargetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedimplants != nil {
		edges = append(edges, target.EdgeImplants)
	}
	if m.removeddeployments != nil {
		edges = append(edges, target.EdgeDeployments)
	}
	if m.removedcredentials != nil {
		edges = append(edges, target.EdgeCredentials)
	}
	if m.removedtags != nil {
		edges = append(edges, target.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TargetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case target.EdgeImplants:
		ids := make([]ent.Value, 0, len(m.removedimplants))
		for id := range m.removedimplants {
			ids = append(ids, id)
		}
		return ids
	case target.EdgeDeployments:
		ids := make([]ent.Value, 0, len(m.removeddeployments))
		for id := range m.removeddeployments {
			ids = append(ids, id)
		}
		return ids
	case target.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.removedcredentials))
		for id := range m.removedcredentials {
			ids = append(ids, id)
		}
		return ids
	case target.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TargetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedimplants {
		edges = append(edges, target.EdgeImplants)
	}
	if m.cleareddeployments {
		edges = append(edges, target.EdgeDeployments)
	}
	if m.clearedcredentials {
		edges = append(edges, target.EdgeCredentials)
	}
	if m.clearedtags {
		edges = append(edges, target.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TargetMutation) EdgeCleared(name string) bool {
	switch name {
	case target.EdgeImplants:
		return m.clearedimplants
	case target.EdgeDeployments:
		return m.cleareddeployments
	case target.EdgeCredentials:
		return m.clearedcredentials
	case target.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TargetMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Target unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TargetMutation) ResetEdge(name string) error {
	switch name {
	case target.EdgeImplants:
		m.ResetImplants()
		return nil
	case target.EdgeDeployments:
		m.ResetDeployments()
		return nil
	case target.EdgeCredentials:
		m.ResetCredentials()
		return nil
	case target.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Target edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	_OAuthID      *string
	_PhotoURL     *string
	_SessionToken *string
	_IsActivated  *bool
	_IsAdmin      *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *UserMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *UserMutation) ResetName() {
	m._Name = nil
}

// SetOAuthID sets the "OAuthID" field.
func (m *UserMutation) SetOAuthID(s string) {
	m._OAuthID = &s
}

// OAuthID returns the value of the "OAuthID" field in the mutation.
func (m *UserMutation) OAuthID() (r string, exists bool) {
	v := m._OAuthID
	if v == nil {
		return
	}
	return *v, true
}

// OldOAuthID returns the old "OAuthID" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOAuthID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOAuthID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOAuthID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOAuthID: %w", err)
	}
	return oldValue.OAuthID, nil
}

// ResetOAuthID resets all changes to the "OAuthID" field.
func (m *UserMutation) ResetOAuthID() {
	m._OAuthID = nil
}

// SetPhotoURL sets the "PhotoURL" field.
func (m *UserMutation) SetPhotoURL(s string) {
	m._PhotoURL = &s
}

// PhotoURL returns the value of the "PhotoURL" field in the mutation.
func (m *UserMutation) PhotoURL() (r string, exists bool) {
	v := m._PhotoURL
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoURL returns the old "PhotoURL" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhotoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoURL: %w", err)
	}
	return oldValue.PhotoURL, nil
}

// ResetPhotoURL resets all changes to the "PhotoURL" field.
func (m *UserMutation) ResetPhotoURL() {
	m._PhotoURL = nil
}

// SetSessionToken sets the "SessionToken" field.
func (m *UserMutation) SetSessionToken(s string) {
	m._SessionToken = &s
}

// SessionToken returns the value of the "SessionToken" field in the mutation.
func (m *UserMutation) SessionToken() (r string, exists bool) {
	v := m._SessionToken
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionToken returns the old "SessionToken" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSessionToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionToken: %w", err)
	}
	return oldValue.SessionToken, nil
}

// ResetSessionToken resets all changes to the "SessionToken" field.
func (m *UserMutation) ResetSessionToken() {
	m._SessionToken = nil
}

// SetIsActivated sets the "IsActivated" field.
func (m *UserMutation) SetIsActivated(b bool) {
	m._IsActivated = &b
}

// IsActivated returns the value of the "IsActivated" field in the mutation.
func (m *UserMutation) IsActivated() (r bool, exists bool) {
	v := m._IsActivated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActivated returns the old "IsActivated" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActivated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActivated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActivated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActivated: %w", err)
	}
	return oldValue.IsActivated, nil
}

// ResetIsActivated resets all changes to the "IsActivated" field.
func (m *UserMutation) ResetIsActivated() {
	m._IsActivated = nil
}

// SetIsAdmin sets the "IsAdmin" field.
func (m *UserMutation) SetIsAdmin(b bool) {
	m._IsAdmin = &b
}

// IsAdmin returns the value of the "IsAdmin" field in the mutation.
func (m *UserMutation) IsAdmin() (r bool, exists bool) {
	v := m._IsAdmin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdmin returns the old "IsAdmin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdmin: %w", err)
	}
	return oldValue.IsAdmin, nil
}

// ResetIsAdmin resets all changes to the "IsAdmin" field.
func (m *UserMutation) ResetIsAdmin() {
	m._IsAdmin = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._Name != nil {
		fields = append(fields, user.FieldName)
	}
	if m._OAuthID != nil {
		fields = append(fields, user.FieldOAuthID)
	}
	if m._PhotoURL != nil {
		fields = append(fields, user.FieldPhotoURL)
	}
	if m._SessionToken != nil {
		fields = append(fields, user.FieldSessionToken)
	}
	if m._IsActivated != nil {
		fields = append(fields, user.FieldIsActivated)
	}
	if m._IsAdmin != nil {
		fields = append(fields, user.FieldIsAdmin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldOAuthID:
		return m.OAuthID()
	case user.FieldPhotoURL:
		return m.PhotoURL()
	case user.FieldSessionToken:
		return m.SessionToken()
	case user.FieldIsActivated:
		return m.IsActivated()
	case user.FieldIsAdmin:
		return m.IsAdmin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldOAuthID:
		return m.OldOAuthID(ctx)
	case user.FieldPhotoURL:
		return m.OldPhotoURL(ctx)
	case user.FieldSessionToken:
		return m.OldSessionToken(ctx)
	case user.FieldIsActivated:
		return m.OldIsActivated(ctx)
	case user.FieldIsAdmin:
		return m.OldIsAdmin(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldOAuthID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOAuthID(v)
		return nil
	case user.FieldPhotoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoURL(v)
		return nil
	case user.FieldSessionToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionToken(v)
		return nil
	case user.FieldIsActivated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActivated(v)
		return nil
	case user.FieldIsAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdmin(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldOAuthID:
		m.ResetOAuthID()
		return nil
	case user.FieldPhotoURL:
		m.ResetPhotoURL()
		return nil
	case user.FieldSessionToken:
		m.ResetSessionToken()
		return nil
	case user.FieldIsActivated:
		m.ResetIsActivated()
		return nil
	case user.FieldIsAdmin:
		m.ResetIsAdmin()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
