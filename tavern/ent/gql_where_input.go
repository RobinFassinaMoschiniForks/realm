// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"time"

	"github.com/kcarretto/realm/tavern/ent/credential"
	"github.com/kcarretto/realm/tavern/ent/deployment"
	"github.com/kcarretto/realm/tavern/ent/deploymentconfig"
	"github.com/kcarretto/realm/tavern/ent/file"
	"github.com/kcarretto/realm/tavern/ent/implant"
	"github.com/kcarretto/realm/tavern/ent/implantcallbackconfig"
	"github.com/kcarretto/realm/tavern/ent/implantconfig"
	"github.com/kcarretto/realm/tavern/ent/implantserviceconfig"
	"github.com/kcarretto/realm/tavern/ent/predicate"
	"github.com/kcarretto/realm/tavern/ent/tag"
	"github.com/kcarretto/realm/tavern/ent/target"
	"github.com/kcarretto/realm/tavern/ent/user"
)

// CredentialWhereInput represents a where input for filtering Credential queries.
type CredentialWhereInput struct {
	Not *CredentialWhereInput   `json:"not,omitempty"`
	Or  []*CredentialWhereInput `json:"or,omitempty"`
	And []*CredentialWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "principal" field predicates.
	Principal             *string  `json:"principal,omitempty"`
	PrincipalNEQ          *string  `json:"principalNEQ,omitempty"`
	PrincipalIn           []string `json:"principalIn,omitempty"`
	PrincipalNotIn        []string `json:"principalNotIn,omitempty"`
	PrincipalGT           *string  `json:"principalGT,omitempty"`
	PrincipalGTE          *string  `json:"principalGTE,omitempty"`
	PrincipalLT           *string  `json:"principalLT,omitempty"`
	PrincipalLTE          *string  `json:"principalLTE,omitempty"`
	PrincipalContains     *string  `json:"principalContains,omitempty"`
	PrincipalHasPrefix    *string  `json:"principalHasPrefix,omitempty"`
	PrincipalHasSuffix    *string  `json:"principalHasSuffix,omitempty"`
	PrincipalEqualFold    *string  `json:"principalEqualFold,omitempty"`
	PrincipalContainsFold *string  `json:"principalContainsFold,omitempty"`

	// "secret" field predicates.
	Secret             *string  `json:"secret,omitempty"`
	SecretNEQ          *string  `json:"secretNEQ,omitempty"`
	SecretIn           []string `json:"secretIn,omitempty"`
	SecretNotIn        []string `json:"secretNotIn,omitempty"`
	SecretGT           *string  `json:"secretGT,omitempty"`
	SecretGTE          *string  `json:"secretGTE,omitempty"`
	SecretLT           *string  `json:"secretLT,omitempty"`
	SecretLTE          *string  `json:"secretLTE,omitempty"`
	SecretContains     *string  `json:"secretContains,omitempty"`
	SecretHasPrefix    *string  `json:"secretHasPrefix,omitempty"`
	SecretHasSuffix    *string  `json:"secretHasSuffix,omitempty"`
	SecretEqualFold    *string  `json:"secretEqualFold,omitempty"`
	SecretContainsFold *string  `json:"secretContainsFold,omitempty"`

	// "kind" field predicates.
	Kind      *credential.Kind  `json:"kind,omitempty"`
	KindNEQ   *credential.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []credential.Kind `json:"kindIn,omitempty"`
	KindNotIn []credential.Kind `json:"kindNotIn,omitempty"`

	// "target" edge predicates.
	HasTarget     *bool               `json:"hasTarget,omitempty"`
	HasTargetWith []*TargetWhereInput `json:"hasTargetWith,omitempty"`
}

// Filter applies the CredentialWhereInput filter on the CredentialQuery builder.
func (i *CredentialWhereInput) Filter(q *CredentialQuery) (*CredentialQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering credentials.
// An error is returned if the input is empty or invalid.
func (i *CredentialWhereInput) P() (predicate.Credential, error) {
	var predicates []predicate.Credential
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, credential.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Credential, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, credential.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Credential, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, credential.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, credential.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, credential.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, credential.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, credential.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, credential.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, credential.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, credential.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, credential.IDLTE(*i.IDLTE))
	}
	if i.Principal != nil {
		predicates = append(predicates, credential.PrincipalEQ(*i.Principal))
	}
	if i.PrincipalNEQ != nil {
		predicates = append(predicates, credential.PrincipalNEQ(*i.PrincipalNEQ))
	}
	if len(i.PrincipalIn) > 0 {
		predicates = append(predicates, credential.PrincipalIn(i.PrincipalIn...))
	}
	if len(i.PrincipalNotIn) > 0 {
		predicates = append(predicates, credential.PrincipalNotIn(i.PrincipalNotIn...))
	}
	if i.PrincipalGT != nil {
		predicates = append(predicates, credential.PrincipalGT(*i.PrincipalGT))
	}
	if i.PrincipalGTE != nil {
		predicates = append(predicates, credential.PrincipalGTE(*i.PrincipalGTE))
	}
	if i.PrincipalLT != nil {
		predicates = append(predicates, credential.PrincipalLT(*i.PrincipalLT))
	}
	if i.PrincipalLTE != nil {
		predicates = append(predicates, credential.PrincipalLTE(*i.PrincipalLTE))
	}
	if i.PrincipalContains != nil {
		predicates = append(predicates, credential.PrincipalContains(*i.PrincipalContains))
	}
	if i.PrincipalHasPrefix != nil {
		predicates = append(predicates, credential.PrincipalHasPrefix(*i.PrincipalHasPrefix))
	}
	if i.PrincipalHasSuffix != nil {
		predicates = append(predicates, credential.PrincipalHasSuffix(*i.PrincipalHasSuffix))
	}
	if i.PrincipalEqualFold != nil {
		predicates = append(predicates, credential.PrincipalEqualFold(*i.PrincipalEqualFold))
	}
	if i.PrincipalContainsFold != nil {
		predicates = append(predicates, credential.PrincipalContainsFold(*i.PrincipalContainsFold))
	}
	if i.Secret != nil {
		predicates = append(predicates, credential.SecretEQ(*i.Secret))
	}
	if i.SecretNEQ != nil {
		predicates = append(predicates, credential.SecretNEQ(*i.SecretNEQ))
	}
	if len(i.SecretIn) > 0 {
		predicates = append(predicates, credential.SecretIn(i.SecretIn...))
	}
	if len(i.SecretNotIn) > 0 {
		predicates = append(predicates, credential.SecretNotIn(i.SecretNotIn...))
	}
	if i.SecretGT != nil {
		predicates = append(predicates, credential.SecretGT(*i.SecretGT))
	}
	if i.SecretGTE != nil {
		predicates = append(predicates, credential.SecretGTE(*i.SecretGTE))
	}
	if i.SecretLT != nil {
		predicates = append(predicates, credential.SecretLT(*i.SecretLT))
	}
	if i.SecretLTE != nil {
		predicates = append(predicates, credential.SecretLTE(*i.SecretLTE))
	}
	if i.SecretContains != nil {
		predicates = append(predicates, credential.SecretContains(*i.SecretContains))
	}
	if i.SecretHasPrefix != nil {
		predicates = append(predicates, credential.SecretHasPrefix(*i.SecretHasPrefix))
	}
	if i.SecretHasSuffix != nil {
		predicates = append(predicates, credential.SecretHasSuffix(*i.SecretHasSuffix))
	}
	if i.SecretEqualFold != nil {
		predicates = append(predicates, credential.SecretEqualFold(*i.SecretEqualFold))
	}
	if i.SecretContainsFold != nil {
		predicates = append(predicates, credential.SecretContainsFold(*i.SecretContainsFold))
	}
	if i.Kind != nil {
		predicates = append(predicates, credential.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, credential.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, credential.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, credential.KindNotIn(i.KindNotIn...))
	}

	if i.HasTarget != nil {
		p := credential.HasTarget()
		if !*i.HasTarget {
			p = credential.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTargetWith) > 0 {
		with := make([]predicate.Target, 0, len(i.HasTargetWith))
		for _, w := range i.HasTargetWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, credential.HasTargetWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/kcarretto/realm/tavern/ent: empty predicate CredentialWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return credential.And(predicates...), nil
	}
}

// DeploymentWhereInput represents a where input for filtering Deployment queries.
type DeploymentWhereInput struct {
	Not *DeploymentWhereInput   `json:"not,omitempty"`
	Or  []*DeploymentWhereInput `json:"or,omitempty"`
	And []*DeploymentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "output" field predicates.
	Output             *string  `json:"output,omitempty"`
	OutputNEQ          *string  `json:"outputNEQ,omitempty"`
	OutputIn           []string `json:"outputIn,omitempty"`
	OutputNotIn        []string `json:"outputNotIn,omitempty"`
	OutputGT           *string  `json:"outputGT,omitempty"`
	OutputGTE          *string  `json:"outputGTE,omitempty"`
	OutputLT           *string  `json:"outputLT,omitempty"`
	OutputLTE          *string  `json:"outputLTE,omitempty"`
	OutputContains     *string  `json:"outputContains,omitempty"`
	OutputHasPrefix    *string  `json:"outputHasPrefix,omitempty"`
	OutputHasSuffix    *string  `json:"outputHasSuffix,omitempty"`
	OutputEqualFold    *string  `json:"outputEqualFold,omitempty"`
	OutputContainsFold *string  `json:"outputContainsFold,omitempty"`

	// "error" field predicates.
	Error             *string  `json:"error,omitempty"`
	ErrorNEQ          *string  `json:"errorNEQ,omitempty"`
	ErrorIn           []string `json:"errorIn,omitempty"`
	ErrorNotIn        []string `json:"errorNotIn,omitempty"`
	ErrorGT           *string  `json:"errorGT,omitempty"`
	ErrorGTE          *string  `json:"errorGTE,omitempty"`
	ErrorLT           *string  `json:"errorLT,omitempty"`
	ErrorLTE          *string  `json:"errorLTE,omitempty"`
	ErrorContains     *string  `json:"errorContains,omitempty"`
	ErrorHasPrefix    *string  `json:"errorHasPrefix,omitempty"`
	ErrorHasSuffix    *string  `json:"errorHasSuffix,omitempty"`
	ErrorEqualFold    *string  `json:"errorEqualFold,omitempty"`
	ErrorContainsFold *string  `json:"errorContainsFold,omitempty"`

	// "queuedAt" field predicates.
	QueuedAt      *time.Time  `json:"queuedat,omitempty"`
	QueuedAtNEQ   *time.Time  `json:"queuedatNEQ,omitempty"`
	QueuedAtIn    []time.Time `json:"queuedatIn,omitempty"`
	QueuedAtNotIn []time.Time `json:"queuedatNotIn,omitempty"`
	QueuedAtGT    *time.Time  `json:"queuedatGT,omitempty"`
	QueuedAtGTE   *time.Time  `json:"queuedatGTE,omitempty"`
	QueuedAtLT    *time.Time  `json:"queuedatLT,omitempty"`
	QueuedAtLTE   *time.Time  `json:"queuedatLTE,omitempty"`

	// "lastModifiedAt" field predicates.
	LastModifiedAt      *time.Time  `json:"lastmodifiedat,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastmodifiedatNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastmodifiedatIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastmodifiedatNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastmodifiedatGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastmodifiedatGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastmodifiedatLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastmodifiedatLTE,omitempty"`

	// "startedAt" field predicates.
	StartedAt       *time.Time  `json:"startedat,omitempty"`
	StartedAtNEQ    *time.Time  `json:"startedatNEQ,omitempty"`
	StartedAtIn     []time.Time `json:"startedatIn,omitempty"`
	StartedAtNotIn  []time.Time `json:"startedatNotIn,omitempty"`
	StartedAtGT     *time.Time  `json:"startedatGT,omitempty"`
	StartedAtGTE    *time.Time  `json:"startedatGTE,omitempty"`
	StartedAtLT     *time.Time  `json:"startedatLT,omitempty"`
	StartedAtLTE    *time.Time  `json:"startedatLTE,omitempty"`
	StartedAtIsNil  bool        `json:"startedatIsNil,omitempty"`
	StartedAtNotNil bool        `json:"startedatNotNil,omitempty"`

	// "finishedAt" field predicates.
	FinishedAt       *time.Time  `json:"finishedat,omitempty"`
	FinishedAtNEQ    *time.Time  `json:"finishedatNEQ,omitempty"`
	FinishedAtIn     []time.Time `json:"finishedatIn,omitempty"`
	FinishedAtNotIn  []time.Time `json:"finishedatNotIn,omitempty"`
	FinishedAtGT     *time.Time  `json:"finishedatGT,omitempty"`
	FinishedAtGTE    *time.Time  `json:"finishedatGTE,omitempty"`
	FinishedAtLT     *time.Time  `json:"finishedatLT,omitempty"`
	FinishedAtLTE    *time.Time  `json:"finishedatLTE,omitempty"`
	FinishedAtIsNil  bool        `json:"finishedatIsNil,omitempty"`
	FinishedAtNotNil bool        `json:"finishedatNotNil,omitempty"`

	// "config" edge predicates.
	HasConfig     *bool                         `json:"hasConfig,omitempty"`
	HasConfigWith []*DeploymentConfigWhereInput `json:"hasConfigWith,omitempty"`

	// "target" edge predicates.
	HasTarget     *bool               `json:"hasTarget,omitempty"`
	HasTargetWith []*TargetWhereInput `json:"hasTargetWith,omitempty"`
}

// Filter applies the DeploymentWhereInput filter on the DeploymentQuery builder.
func (i *DeploymentWhereInput) Filter(q *DeploymentQuery) (*DeploymentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering deployments.
// An error is returned if the input is empty or invalid.
func (i *DeploymentWhereInput) P() (predicate.Deployment, error) {
	var predicates []predicate.Deployment
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, deployment.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Deployment, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, deployment.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Deployment, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, deployment.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, deployment.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deployment.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deployment.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deployment.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deployment.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deployment.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deployment.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deployment.IDLTE(*i.IDLTE))
	}
	if i.Output != nil {
		predicates = append(predicates, deployment.OutputEQ(*i.Output))
	}
	if i.OutputNEQ != nil {
		predicates = append(predicates, deployment.OutputNEQ(*i.OutputNEQ))
	}
	if len(i.OutputIn) > 0 {
		predicates = append(predicates, deployment.OutputIn(i.OutputIn...))
	}
	if len(i.OutputNotIn) > 0 {
		predicates = append(predicates, deployment.OutputNotIn(i.OutputNotIn...))
	}
	if i.OutputGT != nil {
		predicates = append(predicates, deployment.OutputGT(*i.OutputGT))
	}
	if i.OutputGTE != nil {
		predicates = append(predicates, deployment.OutputGTE(*i.OutputGTE))
	}
	if i.OutputLT != nil {
		predicates = append(predicates, deployment.OutputLT(*i.OutputLT))
	}
	if i.OutputLTE != nil {
		predicates = append(predicates, deployment.OutputLTE(*i.OutputLTE))
	}
	if i.OutputContains != nil {
		predicates = append(predicates, deployment.OutputContains(*i.OutputContains))
	}
	if i.OutputHasPrefix != nil {
		predicates = append(predicates, deployment.OutputHasPrefix(*i.OutputHasPrefix))
	}
	if i.OutputHasSuffix != nil {
		predicates = append(predicates, deployment.OutputHasSuffix(*i.OutputHasSuffix))
	}
	if i.OutputEqualFold != nil {
		predicates = append(predicates, deployment.OutputEqualFold(*i.OutputEqualFold))
	}
	if i.OutputContainsFold != nil {
		predicates = append(predicates, deployment.OutputContainsFold(*i.OutputContainsFold))
	}
	if i.Error != nil {
		predicates = append(predicates, deployment.ErrorEQ(*i.Error))
	}
	if i.ErrorNEQ != nil {
		predicates = append(predicates, deployment.ErrorNEQ(*i.ErrorNEQ))
	}
	if len(i.ErrorIn) > 0 {
		predicates = append(predicates, deployment.ErrorIn(i.ErrorIn...))
	}
	if len(i.ErrorNotIn) > 0 {
		predicates = append(predicates, deployment.ErrorNotIn(i.ErrorNotIn...))
	}
	if i.ErrorGT != nil {
		predicates = append(predicates, deployment.ErrorGT(*i.ErrorGT))
	}
	if i.ErrorGTE != nil {
		predicates = append(predicates, deployment.ErrorGTE(*i.ErrorGTE))
	}
	if i.ErrorLT != nil {
		predicates = append(predicates, deployment.ErrorLT(*i.ErrorLT))
	}
	if i.ErrorLTE != nil {
		predicates = append(predicates, deployment.ErrorLTE(*i.ErrorLTE))
	}
	if i.ErrorContains != nil {
		predicates = append(predicates, deployment.ErrorContains(*i.ErrorContains))
	}
	if i.ErrorHasPrefix != nil {
		predicates = append(predicates, deployment.ErrorHasPrefix(*i.ErrorHasPrefix))
	}
	if i.ErrorHasSuffix != nil {
		predicates = append(predicates, deployment.ErrorHasSuffix(*i.ErrorHasSuffix))
	}
	if i.ErrorEqualFold != nil {
		predicates = append(predicates, deployment.ErrorEqualFold(*i.ErrorEqualFold))
	}
	if i.ErrorContainsFold != nil {
		predicates = append(predicates, deployment.ErrorContainsFold(*i.ErrorContainsFold))
	}
	if i.QueuedAt != nil {
		predicates = append(predicates, deployment.QueuedAtEQ(*i.QueuedAt))
	}
	if i.QueuedAtNEQ != nil {
		predicates = append(predicates, deployment.QueuedAtNEQ(*i.QueuedAtNEQ))
	}
	if len(i.QueuedAtIn) > 0 {
		predicates = append(predicates, deployment.QueuedAtIn(i.QueuedAtIn...))
	}
	if len(i.QueuedAtNotIn) > 0 {
		predicates = append(predicates, deployment.QueuedAtNotIn(i.QueuedAtNotIn...))
	}
	if i.QueuedAtGT != nil {
		predicates = append(predicates, deployment.QueuedAtGT(*i.QueuedAtGT))
	}
	if i.QueuedAtGTE != nil {
		predicates = append(predicates, deployment.QueuedAtGTE(*i.QueuedAtGTE))
	}
	if i.QueuedAtLT != nil {
		predicates = append(predicates, deployment.QueuedAtLT(*i.QueuedAtLT))
	}
	if i.QueuedAtLTE != nil {
		predicates = append(predicates, deployment.QueuedAtLTE(*i.QueuedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, deployment.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, deployment.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, deployment.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, deployment.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, deployment.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, deployment.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, deployment.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, deployment.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}
	if i.StartedAt != nil {
		predicates = append(predicates, deployment.StartedAtEQ(*i.StartedAt))
	}
	if i.StartedAtNEQ != nil {
		predicates = append(predicates, deployment.StartedAtNEQ(*i.StartedAtNEQ))
	}
	if len(i.StartedAtIn) > 0 {
		predicates = append(predicates, deployment.StartedAtIn(i.StartedAtIn...))
	}
	if len(i.StartedAtNotIn) > 0 {
		predicates = append(predicates, deployment.StartedAtNotIn(i.StartedAtNotIn...))
	}
	if i.StartedAtGT != nil {
		predicates = append(predicates, deployment.StartedAtGT(*i.StartedAtGT))
	}
	if i.StartedAtGTE != nil {
		predicates = append(predicates, deployment.StartedAtGTE(*i.StartedAtGTE))
	}
	if i.StartedAtLT != nil {
		predicates = append(predicates, deployment.StartedAtLT(*i.StartedAtLT))
	}
	if i.StartedAtLTE != nil {
		predicates = append(predicates, deployment.StartedAtLTE(*i.StartedAtLTE))
	}
	if i.StartedAtIsNil {
		predicates = append(predicates, deployment.StartedAtIsNil())
	}
	if i.StartedAtNotNil {
		predicates = append(predicates, deployment.StartedAtNotNil())
	}
	if i.FinishedAt != nil {
		predicates = append(predicates, deployment.FinishedAtEQ(*i.FinishedAt))
	}
	if i.FinishedAtNEQ != nil {
		predicates = append(predicates, deployment.FinishedAtNEQ(*i.FinishedAtNEQ))
	}
	if len(i.FinishedAtIn) > 0 {
		predicates = append(predicates, deployment.FinishedAtIn(i.FinishedAtIn...))
	}
	if len(i.FinishedAtNotIn) > 0 {
		predicates = append(predicates, deployment.FinishedAtNotIn(i.FinishedAtNotIn...))
	}
	if i.FinishedAtGT != nil {
		predicates = append(predicates, deployment.FinishedAtGT(*i.FinishedAtGT))
	}
	if i.FinishedAtGTE != nil {
		predicates = append(predicates, deployment.FinishedAtGTE(*i.FinishedAtGTE))
	}
	if i.FinishedAtLT != nil {
		predicates = append(predicates, deployment.FinishedAtLT(*i.FinishedAtLT))
	}
	if i.FinishedAtLTE != nil {
		predicates = append(predicates, deployment.FinishedAtLTE(*i.FinishedAtLTE))
	}
	if i.FinishedAtIsNil {
		predicates = append(predicates, deployment.FinishedAtIsNil())
	}
	if i.FinishedAtNotNil {
		predicates = append(predicates, deployment.FinishedAtNotNil())
	}

	if i.HasConfig != nil {
		p := deployment.HasConfig()
		if !*i.HasConfig {
			p = deployment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConfigWith) > 0 {
		with := make([]predicate.DeploymentConfig, 0, len(i.HasConfigWith))
		for _, w := range i.HasConfigWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deployment.HasConfigWith(with...))
	}
	if i.HasTarget != nil {
		p := deployment.HasTarget()
		if !*i.HasTarget {
			p = deployment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTargetWith) > 0 {
		with := make([]predicate.Target, 0, len(i.HasTargetWith))
		for _, w := range i.HasTargetWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deployment.HasTargetWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/kcarretto/realm/tavern/ent: empty predicate DeploymentWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return deployment.And(predicates...), nil
	}
}

// DeploymentConfigWhereInput represents a where input for filtering DeploymentConfig queries.
type DeploymentConfigWhereInput struct {
	Not *DeploymentConfigWhereInput   `json:"not,omitempty"`
	Or  []*DeploymentConfigWhereInput `json:"or,omitempty"`
	And []*DeploymentConfigWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "cmd" field predicates.
	Cmd             *string  `json:"cmd,omitempty"`
	CmdNEQ          *string  `json:"cmdNEQ,omitempty"`
	CmdIn           []string `json:"cmdIn,omitempty"`
	CmdNotIn        []string `json:"cmdNotIn,omitempty"`
	CmdGT           *string  `json:"cmdGT,omitempty"`
	CmdGTE          *string  `json:"cmdGTE,omitempty"`
	CmdLT           *string  `json:"cmdLT,omitempty"`
	CmdLTE          *string  `json:"cmdLTE,omitempty"`
	CmdContains     *string  `json:"cmdContains,omitempty"`
	CmdHasPrefix    *string  `json:"cmdHasPrefix,omitempty"`
	CmdHasSuffix    *string  `json:"cmdHasSuffix,omitempty"`
	CmdEqualFold    *string  `json:"cmdEqualFold,omitempty"`
	CmdContainsFold *string  `json:"cmdContainsFold,omitempty"`

	// "startCmd" field predicates.
	StartCmd    *bool `json:"startcmd,omitempty"`
	StartCmdNEQ *bool `json:"startcmdNEQ,omitempty"`

	// "fileDst" field predicates.
	FileDst             *string  `json:"filedst,omitempty"`
	FileDstNEQ          *string  `json:"filedstNEQ,omitempty"`
	FileDstIn           []string `json:"filedstIn,omitempty"`
	FileDstNotIn        []string `json:"filedstNotIn,omitempty"`
	FileDstGT           *string  `json:"filedstGT,omitempty"`
	FileDstGTE          *string  `json:"filedstGTE,omitempty"`
	FileDstLT           *string  `json:"filedstLT,omitempty"`
	FileDstLTE          *string  `json:"filedstLTE,omitempty"`
	FileDstContains     *string  `json:"filedstContains,omitempty"`
	FileDstHasPrefix    *string  `json:"filedstHasPrefix,omitempty"`
	FileDstHasSuffix    *string  `json:"filedstHasSuffix,omitempty"`
	FileDstEqualFold    *string  `json:"filedstEqualFold,omitempty"`
	FileDstContainsFold *string  `json:"filedstContainsFold,omitempty"`

	// "deployments" edge predicates.
	HasDeployments     *bool                   `json:"hasDeployments,omitempty"`
	HasDeploymentsWith []*DeploymentWhereInput `json:"hasDeploymentsWith,omitempty"`

	// "file" edge predicates.
	HasFile     *bool             `json:"hasFile,omitempty"`
	HasFileWith []*FileWhereInput `json:"hasFileWith,omitempty"`

	// "implantConfig" edge predicates.
	HasImplantConfig     *bool                      `json:"hasImplantConfig,omitempty"`
	HasImplantConfigWith []*ImplantConfigWhereInput `json:"hasImplantConfigWith,omitempty"`
}

// Filter applies the DeploymentConfigWhereInput filter on the DeploymentConfigQuery builder.
func (i *DeploymentConfigWhereInput) Filter(q *DeploymentConfigQuery) (*DeploymentConfigQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering deploymentconfigs.
// An error is returned if the input is empty or invalid.
func (i *DeploymentConfigWhereInput) P() (predicate.DeploymentConfig, error) {
	var predicates []predicate.DeploymentConfig
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, deploymentconfig.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeploymentConfig, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, deploymentconfig.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeploymentConfig, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, deploymentconfig.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, deploymentconfig.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deploymentconfig.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deploymentconfig.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deploymentconfig.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deploymentconfig.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deploymentconfig.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deploymentconfig.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deploymentconfig.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, deploymentconfig.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, deploymentconfig.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, deploymentconfig.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, deploymentconfig.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, deploymentconfig.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, deploymentconfig.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, deploymentconfig.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, deploymentconfig.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, deploymentconfig.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, deploymentconfig.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, deploymentconfig.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, deploymentconfig.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, deploymentconfig.NameContainsFold(*i.NameContainsFold))
	}
	if i.Cmd != nil {
		predicates = append(predicates, deploymentconfig.CmdEQ(*i.Cmd))
	}
	if i.CmdNEQ != nil {
		predicates = append(predicates, deploymentconfig.CmdNEQ(*i.CmdNEQ))
	}
	if len(i.CmdIn) > 0 {
		predicates = append(predicates, deploymentconfig.CmdIn(i.CmdIn...))
	}
	if len(i.CmdNotIn) > 0 {
		predicates = append(predicates, deploymentconfig.CmdNotIn(i.CmdNotIn...))
	}
	if i.CmdGT != nil {
		predicates = append(predicates, deploymentconfig.CmdGT(*i.CmdGT))
	}
	if i.CmdGTE != nil {
		predicates = append(predicates, deploymentconfig.CmdGTE(*i.CmdGTE))
	}
	if i.CmdLT != nil {
		predicates = append(predicates, deploymentconfig.CmdLT(*i.CmdLT))
	}
	if i.CmdLTE != nil {
		predicates = append(predicates, deploymentconfig.CmdLTE(*i.CmdLTE))
	}
	if i.CmdContains != nil {
		predicates = append(predicates, deploymentconfig.CmdContains(*i.CmdContains))
	}
	if i.CmdHasPrefix != nil {
		predicates = append(predicates, deploymentconfig.CmdHasPrefix(*i.CmdHasPrefix))
	}
	if i.CmdHasSuffix != nil {
		predicates = append(predicates, deploymentconfig.CmdHasSuffix(*i.CmdHasSuffix))
	}
	if i.CmdEqualFold != nil {
		predicates = append(predicates, deploymentconfig.CmdEqualFold(*i.CmdEqualFold))
	}
	if i.CmdContainsFold != nil {
		predicates = append(predicates, deploymentconfig.CmdContainsFold(*i.CmdContainsFold))
	}
	if i.StartCmd != nil {
		predicates = append(predicates, deploymentconfig.StartCmdEQ(*i.StartCmd))
	}
	if i.StartCmdNEQ != nil {
		predicates = append(predicates, deploymentconfig.StartCmdNEQ(*i.StartCmdNEQ))
	}
	if i.FileDst != nil {
		predicates = append(predicates, deploymentconfig.FileDstEQ(*i.FileDst))
	}
	if i.FileDstNEQ != nil {
		predicates = append(predicates, deploymentconfig.FileDstNEQ(*i.FileDstNEQ))
	}
	if len(i.FileDstIn) > 0 {
		predicates = append(predicates, deploymentconfig.FileDstIn(i.FileDstIn...))
	}
	if len(i.FileDstNotIn) > 0 {
		predicates = append(predicates, deploymentconfig.FileDstNotIn(i.FileDstNotIn...))
	}
	if i.FileDstGT != nil {
		predicates = append(predicates, deploymentconfig.FileDstGT(*i.FileDstGT))
	}
	if i.FileDstGTE != nil {
		predicates = append(predicates, deploymentconfig.FileDstGTE(*i.FileDstGTE))
	}
	if i.FileDstLT != nil {
		predicates = append(predicates, deploymentconfig.FileDstLT(*i.FileDstLT))
	}
	if i.FileDstLTE != nil {
		predicates = append(predicates, deploymentconfig.FileDstLTE(*i.FileDstLTE))
	}
	if i.FileDstContains != nil {
		predicates = append(predicates, deploymentconfig.FileDstContains(*i.FileDstContains))
	}
	if i.FileDstHasPrefix != nil {
		predicates = append(predicates, deploymentconfig.FileDstHasPrefix(*i.FileDstHasPrefix))
	}
	if i.FileDstHasSuffix != nil {
		predicates = append(predicates, deploymentconfig.FileDstHasSuffix(*i.FileDstHasSuffix))
	}
	if i.FileDstEqualFold != nil {
		predicates = append(predicates, deploymentconfig.FileDstEqualFold(*i.FileDstEqualFold))
	}
	if i.FileDstContainsFold != nil {
		predicates = append(predicates, deploymentconfig.FileDstContainsFold(*i.FileDstContainsFold))
	}

	if i.HasDeployments != nil {
		p := deploymentconfig.HasDeployments()
		if !*i.HasDeployments {
			p = deploymentconfig.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeploymentsWith) > 0 {
		with := make([]predicate.Deployment, 0, len(i.HasDeploymentsWith))
		for _, w := range i.HasDeploymentsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deploymentconfig.HasDeploymentsWith(with...))
	}
	if i.HasFile != nil {
		p := deploymentconfig.HasFile()
		if !*i.HasFile {
			p = deploymentconfig.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFileWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFileWith))
		for _, w := range i.HasFileWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deploymentconfig.HasFileWith(with...))
	}
	if i.HasImplantConfig != nil {
		p := deploymentconfig.HasImplantConfig()
		if !*i.HasImplantConfig {
			p = deploymentconfig.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasImplantConfigWith) > 0 {
		with := make([]predicate.ImplantConfig, 0, len(i.HasImplantConfigWith))
		for _, w := range i.HasImplantConfigWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, deploymentconfig.HasImplantConfigWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/kcarretto/realm/tavern/ent: empty predicate DeploymentConfigWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return deploymentconfig.And(predicates...), nil
	}
}

// FileWhereInput represents a where input for filtering File queries.
type FileWhereInput struct {
	Not *FileWhereInput   `json:"not,omitempty"`
	Or  []*FileWhereInput `json:"or,omitempty"`
	And []*FileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "size" field predicates.
	Size      *int  `json:"size,omitempty"`
	SizeNEQ   *int  `json:"sizeNEQ,omitempty"`
	SizeIn    []int `json:"sizeIn,omitempty"`
	SizeNotIn []int `json:"sizeNotIn,omitempty"`
	SizeGT    *int  `json:"sizeGT,omitempty"`
	SizeGTE   *int  `json:"sizeGTE,omitempty"`
	SizeLT    *int  `json:"sizeLT,omitempty"`
	SizeLTE   *int  `json:"sizeLTE,omitempty"`

	// "hash" field predicates.
	Hash             *string  `json:"hash,omitempty"`
	HashNEQ          *string  `json:"hashNEQ,omitempty"`
	HashIn           []string `json:"hashIn,omitempty"`
	HashNotIn        []string `json:"hashNotIn,omitempty"`
	HashGT           *string  `json:"hashGT,omitempty"`
	HashGTE          *string  `json:"hashGTE,omitempty"`
	HashLT           *string  `json:"hashLT,omitempty"`
	HashLTE          *string  `json:"hashLTE,omitempty"`
	HashContains     *string  `json:"hashContains,omitempty"`
	HashHasPrefix    *string  `json:"hashHasPrefix,omitempty"`
	HashHasSuffix    *string  `json:"hashHasSuffix,omitempty"`
	HashEqualFold    *string  `json:"hashEqualFold,omitempty"`
	HashContainsFold *string  `json:"hashContainsFold,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "lastModifiedAt" field predicates.
	LastModifiedAt      *time.Time  `json:"lastmodifiedat,omitempty"`
	LastModifiedAtNEQ   *time.Time  `json:"lastmodifiedatNEQ,omitempty"`
	LastModifiedAtIn    []time.Time `json:"lastmodifiedatIn,omitempty"`
	LastModifiedAtNotIn []time.Time `json:"lastmodifiedatNotIn,omitempty"`
	LastModifiedAtGT    *time.Time  `json:"lastmodifiedatGT,omitempty"`
	LastModifiedAtGTE   *time.Time  `json:"lastmodifiedatGTE,omitempty"`
	LastModifiedAtLT    *time.Time  `json:"lastmodifiedatLT,omitempty"`
	LastModifiedAtLTE   *time.Time  `json:"lastmodifiedatLTE,omitempty"`

	// "deploymentConfigs" edge predicates.
	HasDeploymentConfigs     *bool                         `json:"hasDeploymentConfigs,omitempty"`
	HasDeploymentConfigsWith []*DeploymentConfigWhereInput `json:"hasDeploymentConfigsWith,omitempty"`
}

// Filter applies the FileWhereInput filter on the FileQuery builder.
func (i *FileWhereInput) Filter(q *FileQuery) (*FileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering files.
// An error is returned if the input is empty or invalid.
func (i *FileWhereInput) P() (predicate.File, error) {
	var predicates []predicate.File
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, file.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.File, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, file.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.File, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, file.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, file.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, file.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, file.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, file.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, file.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, file.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, file.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, file.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, file.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, file.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, file.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, file.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, file.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, file.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, file.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, file.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, file.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, file.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, file.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, file.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, file.NameContainsFold(*i.NameContainsFold))
	}
	if i.Size != nil {
		predicates = append(predicates, file.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, file.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, file.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, file.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, file.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, file.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, file.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, file.SizeLTE(*i.SizeLTE))
	}
	if i.Hash != nil {
		predicates = append(predicates, file.HashEQ(*i.Hash))
	}
	if i.HashNEQ != nil {
		predicates = append(predicates, file.HashNEQ(*i.HashNEQ))
	}
	if len(i.HashIn) > 0 {
		predicates = append(predicates, file.HashIn(i.HashIn...))
	}
	if len(i.HashNotIn) > 0 {
		predicates = append(predicates, file.HashNotIn(i.HashNotIn...))
	}
	if i.HashGT != nil {
		predicates = append(predicates, file.HashGT(*i.HashGT))
	}
	if i.HashGTE != nil {
		predicates = append(predicates, file.HashGTE(*i.HashGTE))
	}
	if i.HashLT != nil {
		predicates = append(predicates, file.HashLT(*i.HashLT))
	}
	if i.HashLTE != nil {
		predicates = append(predicates, file.HashLTE(*i.HashLTE))
	}
	if i.HashContains != nil {
		predicates = append(predicates, file.HashContains(*i.HashContains))
	}
	if i.HashHasPrefix != nil {
		predicates = append(predicates, file.HashHasPrefix(*i.HashHasPrefix))
	}
	if i.HashHasSuffix != nil {
		predicates = append(predicates, file.HashHasSuffix(*i.HashHasSuffix))
	}
	if i.HashEqualFold != nil {
		predicates = append(predicates, file.HashEqualFold(*i.HashEqualFold))
	}
	if i.HashContainsFold != nil {
		predicates = append(predicates, file.HashContainsFold(*i.HashContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, file.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, file.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, file.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, file.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, file.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, file.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, file.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, file.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastModifiedAt != nil {
		predicates = append(predicates, file.LastModifiedAtEQ(*i.LastModifiedAt))
	}
	if i.LastModifiedAtNEQ != nil {
		predicates = append(predicates, file.LastModifiedAtNEQ(*i.LastModifiedAtNEQ))
	}
	if len(i.LastModifiedAtIn) > 0 {
		predicates = append(predicates, file.LastModifiedAtIn(i.LastModifiedAtIn...))
	}
	if len(i.LastModifiedAtNotIn) > 0 {
		predicates = append(predicates, file.LastModifiedAtNotIn(i.LastModifiedAtNotIn...))
	}
	if i.LastModifiedAtGT != nil {
		predicates = append(predicates, file.LastModifiedAtGT(*i.LastModifiedAtGT))
	}
	if i.LastModifiedAtGTE != nil {
		predicates = append(predicates, file.LastModifiedAtGTE(*i.LastModifiedAtGTE))
	}
	if i.LastModifiedAtLT != nil {
		predicates = append(predicates, file.LastModifiedAtLT(*i.LastModifiedAtLT))
	}
	if i.LastModifiedAtLTE != nil {
		predicates = append(predicates, file.LastModifiedAtLTE(*i.LastModifiedAtLTE))
	}

	if i.HasDeploymentConfigs != nil {
		p := file.HasDeploymentConfigs()
		if !*i.HasDeploymentConfigs {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeploymentConfigsWith) > 0 {
		with := make([]predicate.DeploymentConfig, 0, len(i.HasDeploymentConfigsWith))
		for _, w := range i.HasDeploymentConfigsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasDeploymentConfigsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/kcarretto/realm/tavern/ent: empty predicate FileWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return file.And(predicates...), nil
	}
}

// ImplantWhereInput represents a where input for filtering Implant queries.
type ImplantWhereInput struct {
	Not *ImplantWhereInput   `json:"not,omitempty"`
	Or  []*ImplantWhereInput `json:"or,omitempty"`
	And []*ImplantWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "sessionID" field predicates.
	SessionID             *string  `json:"sessionid,omitempty"`
	SessionIDNEQ          *string  `json:"sessionidNEQ,omitempty"`
	SessionIDIn           []string `json:"sessionidIn,omitempty"`
	SessionIDNotIn        []string `json:"sessionidNotIn,omitempty"`
	SessionIDGT           *string  `json:"sessionidGT,omitempty"`
	SessionIDGTE          *string  `json:"sessionidGTE,omitempty"`
	SessionIDLT           *string  `json:"sessionidLT,omitempty"`
	SessionIDLTE          *string  `json:"sessionidLTE,omitempty"`
	SessionIDContains     *string  `json:"sessionidContains,omitempty"`
	SessionIDHasPrefix    *string  `json:"sessionidHasPrefix,omitempty"`
	SessionIDHasSuffix    *string  `json:"sessionidHasSuffix,omitempty"`
	SessionIDEqualFold    *string  `json:"sessionidEqualFold,omitempty"`
	SessionIDContainsFold *string  `json:"sessionidContainsFold,omitempty"`

	// "processName" field predicates.
	ProcessName             *string  `json:"processname,omitempty"`
	ProcessNameNEQ          *string  `json:"processnameNEQ,omitempty"`
	ProcessNameIn           []string `json:"processnameIn,omitempty"`
	ProcessNameNotIn        []string `json:"processnameNotIn,omitempty"`
	ProcessNameGT           *string  `json:"processnameGT,omitempty"`
	ProcessNameGTE          *string  `json:"processnameGTE,omitempty"`
	ProcessNameLT           *string  `json:"processnameLT,omitempty"`
	ProcessNameLTE          *string  `json:"processnameLTE,omitempty"`
	ProcessNameContains     *string  `json:"processnameContains,omitempty"`
	ProcessNameHasPrefix    *string  `json:"processnameHasPrefix,omitempty"`
	ProcessNameHasSuffix    *string  `json:"processnameHasSuffix,omitempty"`
	ProcessNameIsNil        bool     `json:"processnameIsNil,omitempty"`
	ProcessNameNotNil       bool     `json:"processnameNotNil,omitempty"`
	ProcessNameEqualFold    *string  `json:"processnameEqualFold,omitempty"`
	ProcessNameContainsFold *string  `json:"processnameContainsFold,omitempty"`

	// "target" edge predicates.
	HasTarget     *bool               `json:"hasTarget,omitempty"`
	HasTargetWith []*TargetWhereInput `json:"hasTargetWith,omitempty"`

	// "config" edge predicates.
	HasConfig     *bool                      `json:"hasConfig,omitempty"`
	HasConfigWith []*ImplantConfigWhereInput `json:"hasConfigWith,omitempty"`
}

// Filter applies the ImplantWhereInput filter on the ImplantQuery builder.
func (i *ImplantWhereInput) Filter(q *ImplantQuery) (*ImplantQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering implants.
// An error is returned if the input is empty or invalid.
func (i *ImplantWhereInput) P() (predicate.Implant, error) {
	var predicates []predicate.Implant
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, implant.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Implant, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, implant.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Implant, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, implant.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, implant.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, implant.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, implant.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, implant.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, implant.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, implant.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, implant.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, implant.IDLTE(*i.IDLTE))
	}
	if i.SessionID != nil {
		predicates = append(predicates, implant.SessionIDEQ(*i.SessionID))
	}
	if i.SessionIDNEQ != nil {
		predicates = append(predicates, implant.SessionIDNEQ(*i.SessionIDNEQ))
	}
	if len(i.SessionIDIn) > 0 {
		predicates = append(predicates, implant.SessionIDIn(i.SessionIDIn...))
	}
	if len(i.SessionIDNotIn) > 0 {
		predicates = append(predicates, implant.SessionIDNotIn(i.SessionIDNotIn...))
	}
	if i.SessionIDGT != nil {
		predicates = append(predicates, implant.SessionIDGT(*i.SessionIDGT))
	}
	if i.SessionIDGTE != nil {
		predicates = append(predicates, implant.SessionIDGTE(*i.SessionIDGTE))
	}
	if i.SessionIDLT != nil {
		predicates = append(predicates, implant.SessionIDLT(*i.SessionIDLT))
	}
	if i.SessionIDLTE != nil {
		predicates = append(predicates, implant.SessionIDLTE(*i.SessionIDLTE))
	}
	if i.SessionIDContains != nil {
		predicates = append(predicates, implant.SessionIDContains(*i.SessionIDContains))
	}
	if i.SessionIDHasPrefix != nil {
		predicates = append(predicates, implant.SessionIDHasPrefix(*i.SessionIDHasPrefix))
	}
	if i.SessionIDHasSuffix != nil {
		predicates = append(predicates, implant.SessionIDHasSuffix(*i.SessionIDHasSuffix))
	}
	if i.SessionIDEqualFold != nil {
		predicates = append(predicates, implant.SessionIDEqualFold(*i.SessionIDEqualFold))
	}
	if i.SessionIDContainsFold != nil {
		predicates = append(predicates, implant.SessionIDContainsFold(*i.SessionIDContainsFold))
	}
	if i.ProcessName != nil {
		predicates = append(predicates, implant.ProcessNameEQ(*i.ProcessName))
	}
	if i.ProcessNameNEQ != nil {
		predicates = append(predicates, implant.ProcessNameNEQ(*i.ProcessNameNEQ))
	}
	if len(i.ProcessNameIn) > 0 {
		predicates = append(predicates, implant.ProcessNameIn(i.ProcessNameIn...))
	}
	if len(i.ProcessNameNotIn) > 0 {
		predicates = append(predicates, implant.ProcessNameNotIn(i.ProcessNameNotIn...))
	}
	if i.ProcessNameGT != nil {
		predicates = append(predicates, implant.ProcessNameGT(*i.ProcessNameGT))
	}
	if i.ProcessNameGTE != nil {
		predicates = append(predicates, implant.ProcessNameGTE(*i.ProcessNameGTE))
	}
	if i.ProcessNameLT != nil {
		predicates = append(predicates, implant.ProcessNameLT(*i.ProcessNameLT))
	}
	if i.ProcessNameLTE != nil {
		predicates = append(predicates, implant.ProcessNameLTE(*i.ProcessNameLTE))
	}
	if i.ProcessNameContains != nil {
		predicates = append(predicates, implant.ProcessNameContains(*i.ProcessNameContains))
	}
	if i.ProcessNameHasPrefix != nil {
		predicates = append(predicates, implant.ProcessNameHasPrefix(*i.ProcessNameHasPrefix))
	}
	if i.ProcessNameHasSuffix != nil {
		predicates = append(predicates, implant.ProcessNameHasSuffix(*i.ProcessNameHasSuffix))
	}
	if i.ProcessNameIsNil {
		predicates = append(predicates, implant.ProcessNameIsNil())
	}
	if i.ProcessNameNotNil {
		predicates = append(predicates, implant.ProcessNameNotNil())
	}
	if i.ProcessNameEqualFold != nil {
		predicates = append(predicates, implant.ProcessNameEqualFold(*i.ProcessNameEqualFold))
	}
	if i.ProcessNameContainsFold != nil {
		predicates = append(predicates, implant.ProcessNameContainsFold(*i.ProcessNameContainsFold))
	}

	if i.HasTarget != nil {
		p := implant.HasTarget()
		if !*i.HasTarget {
			p = implant.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTargetWith) > 0 {
		with := make([]predicate.Target, 0, len(i.HasTargetWith))
		for _, w := range i.HasTargetWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, implant.HasTargetWith(with...))
	}
	if i.HasConfig != nil {
		p := implant.HasConfig()
		if !*i.HasConfig {
			p = implant.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConfigWith) > 0 {
		with := make([]predicate.ImplantConfig, 0, len(i.HasConfigWith))
		for _, w := range i.HasConfigWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, implant.HasConfigWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/kcarretto/realm/tavern/ent: empty predicate ImplantWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return implant.And(predicates...), nil
	}
}

// ImplantCallbackConfigWhereInput represents a where input for filtering ImplantCallbackConfig queries.
type ImplantCallbackConfigWhereInput struct {
	Not *ImplantCallbackConfigWhereInput   `json:"not,omitempty"`
	Or  []*ImplantCallbackConfigWhereInput `json:"or,omitempty"`
	And []*ImplantCallbackConfigWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "uri" field predicates.
	URI             *string  `json:"uri,omitempty"`
	URINEQ          *string  `json:"uriNEQ,omitempty"`
	URIIn           []string `json:"uriIn,omitempty"`
	URINotIn        []string `json:"uriNotIn,omitempty"`
	URIGT           *string  `json:"uriGT,omitempty"`
	URIGTE          *string  `json:"uriGTE,omitempty"`
	URILT           *string  `json:"uriLT,omitempty"`
	URILTE          *string  `json:"uriLTE,omitempty"`
	URIContains     *string  `json:"uriContains,omitempty"`
	URIHasPrefix    *string  `json:"uriHasPrefix,omitempty"`
	URIHasSuffix    *string  `json:"uriHasSuffix,omitempty"`
	URIEqualFold    *string  `json:"uriEqualFold,omitempty"`
	URIContainsFold *string  `json:"uriContainsFold,omitempty"`

	// "proxyURI" field predicates.
	ProxyURI             *string  `json:"proxyuri,omitempty"`
	ProxyURINEQ          *string  `json:"proxyuriNEQ,omitempty"`
	ProxyURIIn           []string `json:"proxyuriIn,omitempty"`
	ProxyURINotIn        []string `json:"proxyuriNotIn,omitempty"`
	ProxyURIGT           *string  `json:"proxyuriGT,omitempty"`
	ProxyURIGTE          *string  `json:"proxyuriGTE,omitempty"`
	ProxyURILT           *string  `json:"proxyuriLT,omitempty"`
	ProxyURILTE          *string  `json:"proxyuriLTE,omitempty"`
	ProxyURIContains     *string  `json:"proxyuriContains,omitempty"`
	ProxyURIHasPrefix    *string  `json:"proxyuriHasPrefix,omitempty"`
	ProxyURIHasSuffix    *string  `json:"proxyuriHasSuffix,omitempty"`
	ProxyURIIsNil        bool     `json:"proxyuriIsNil,omitempty"`
	ProxyURINotNil       bool     `json:"proxyuriNotNil,omitempty"`
	ProxyURIEqualFold    *string  `json:"proxyuriEqualFold,omitempty"`
	ProxyURIContainsFold *string  `json:"proxyuriContainsFold,omitempty"`

	// "priority" field predicates.
	Priority      *int  `json:"priority,omitempty"`
	PriorityNEQ   *int  `json:"priorityNEQ,omitempty"`
	PriorityIn    []int `json:"priorityIn,omitempty"`
	PriorityNotIn []int `json:"priorityNotIn,omitempty"`
	PriorityGT    *int  `json:"priorityGT,omitempty"`
	PriorityGTE   *int  `json:"priorityGTE,omitempty"`
	PriorityLT    *int  `json:"priorityLT,omitempty"`
	PriorityLTE   *int  `json:"priorityLTE,omitempty"`

	// "timeout" field predicates.
	Timeout      *int  `json:"timeout,omitempty"`
	TimeoutNEQ   *int  `json:"timeoutNEQ,omitempty"`
	TimeoutIn    []int `json:"timeoutIn,omitempty"`
	TimeoutNotIn []int `json:"timeoutNotIn,omitempty"`
	TimeoutGT    *int  `json:"timeoutGT,omitempty"`
	TimeoutGTE   *int  `json:"timeoutGTE,omitempty"`
	TimeoutLT    *int  `json:"timeoutLT,omitempty"`
	TimeoutLTE   *int  `json:"timeoutLTE,omitempty"`

	// "interval" field predicates.
	Interval      *int  `json:"interval,omitempty"`
	IntervalNEQ   *int  `json:"intervalNEQ,omitempty"`
	IntervalIn    []int `json:"intervalIn,omitempty"`
	IntervalNotIn []int `json:"intervalNotIn,omitempty"`
	IntervalGT    *int  `json:"intervalGT,omitempty"`
	IntervalGTE   *int  `json:"intervalGTE,omitempty"`
	IntervalLT    *int  `json:"intervalLT,omitempty"`
	IntervalLTE   *int  `json:"intervalLTE,omitempty"`

	// "jitter" field predicates.
	Jitter      *int  `json:"jitter,omitempty"`
	JitterNEQ   *int  `json:"jitterNEQ,omitempty"`
	JitterIn    []int `json:"jitterIn,omitempty"`
	JitterNotIn []int `json:"jitterNotIn,omitempty"`
	JitterGT    *int  `json:"jitterGT,omitempty"`
	JitterGTE   *int  `json:"jitterGTE,omitempty"`
	JitterLT    *int  `json:"jitterLT,omitempty"`
	JitterLTE   *int  `json:"jitterLTE,omitempty"`

	// "implantConfigs" edge predicates.
	HasImplantConfigs     *bool                      `json:"hasImplantConfigs,omitempty"`
	HasImplantConfigsWith []*ImplantConfigWhereInput `json:"hasImplantConfigsWith,omitempty"`
}

// Filter applies the ImplantCallbackConfigWhereInput filter on the ImplantCallbackConfigQuery builder.
func (i *ImplantCallbackConfigWhereInput) Filter(q *ImplantCallbackConfigQuery) (*ImplantCallbackConfigQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering implantcallbackconfigs.
// An error is returned if the input is empty or invalid.
func (i *ImplantCallbackConfigWhereInput) P() (predicate.ImplantCallbackConfig, error) {
	var predicates []predicate.ImplantCallbackConfig
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, implantcallbackconfig.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ImplantCallbackConfig, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, implantcallbackconfig.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ImplantCallbackConfig, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, implantcallbackconfig.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, implantcallbackconfig.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, implantcallbackconfig.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, implantcallbackconfig.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, implantcallbackconfig.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, implantcallbackconfig.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, implantcallbackconfig.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, implantcallbackconfig.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, implantcallbackconfig.IDLTE(*i.IDLTE))
	}
	if i.URI != nil {
		predicates = append(predicates, implantcallbackconfig.URIEQ(*i.URI))
	}
	if i.URINEQ != nil {
		predicates = append(predicates, implantcallbackconfig.URINEQ(*i.URINEQ))
	}
	if len(i.URIIn) > 0 {
		predicates = append(predicates, implantcallbackconfig.URIIn(i.URIIn...))
	}
	if len(i.URINotIn) > 0 {
		predicates = append(predicates, implantcallbackconfig.URINotIn(i.URINotIn...))
	}
	if i.URIGT != nil {
		predicates = append(predicates, implantcallbackconfig.URIGT(*i.URIGT))
	}
	if i.URIGTE != nil {
		predicates = append(predicates, implantcallbackconfig.URIGTE(*i.URIGTE))
	}
	if i.URILT != nil {
		predicates = append(predicates, implantcallbackconfig.URILT(*i.URILT))
	}
	if i.URILTE != nil {
		predicates = append(predicates, implantcallbackconfig.URILTE(*i.URILTE))
	}
	if i.URIContains != nil {
		predicates = append(predicates, implantcallbackconfig.URIContains(*i.URIContains))
	}
	if i.URIHasPrefix != nil {
		predicates = append(predicates, implantcallbackconfig.URIHasPrefix(*i.URIHasPrefix))
	}
	if i.URIHasSuffix != nil {
		predicates = append(predicates, implantcallbackconfig.URIHasSuffix(*i.URIHasSuffix))
	}
	if i.URIEqualFold != nil {
		predicates = append(predicates, implantcallbackconfig.URIEqualFold(*i.URIEqualFold))
	}
	if i.URIContainsFold != nil {
		predicates = append(predicates, implantcallbackconfig.URIContainsFold(*i.URIContainsFold))
	}
	if i.ProxyURI != nil {
		predicates = append(predicates, implantcallbackconfig.ProxyURIEQ(*i.ProxyURI))
	}
	if i.ProxyURINEQ != nil {
		predicates = append(predicates, implantcallbackconfig.ProxyURINEQ(*i.ProxyURINEQ))
	}
	if len(i.ProxyURIIn) > 0 {
		predicates = append(predicates, implantcallbackconfig.ProxyURIIn(i.ProxyURIIn...))
	}
	if len(i.ProxyURINotIn) > 0 {
		predicates = append(predicates, implantcallbackconfig.ProxyURINotIn(i.ProxyURINotIn...))
	}
	if i.ProxyURIGT != nil {
		predicates = append(predicates, implantcallbackconfig.ProxyURIGT(*i.ProxyURIGT))
	}
	if i.ProxyURIGTE != nil {
		predicates = append(predicates, implantcallbackconfig.ProxyURIGTE(*i.ProxyURIGTE))
	}
	if i.ProxyURILT != nil {
		predicates = append(predicates, implantcallbackconfig.ProxyURILT(*i.ProxyURILT))
	}
	if i.ProxyURILTE != nil {
		predicates = append(predicates, implantcallbackconfig.ProxyURILTE(*i.ProxyURILTE))
	}
	if i.ProxyURIContains != nil {
		predicates = append(predicates, implantcallbackconfig.ProxyURIContains(*i.ProxyURIContains))
	}
	if i.ProxyURIHasPrefix != nil {
		predicates = append(predicates, implantcallbackconfig.ProxyURIHasPrefix(*i.ProxyURIHasPrefix))
	}
	if i.ProxyURIHasSuffix != nil {
		predicates = append(predicates, implantcallbackconfig.ProxyURIHasSuffix(*i.ProxyURIHasSuffix))
	}
	if i.ProxyURIIsNil {
		predicates = append(predicates, implantcallbackconfig.ProxyURIIsNil())
	}
	if i.ProxyURINotNil {
		predicates = append(predicates, implantcallbackconfig.ProxyURINotNil())
	}
	if i.ProxyURIEqualFold != nil {
		predicates = append(predicates, implantcallbackconfig.ProxyURIEqualFold(*i.ProxyURIEqualFold))
	}
	if i.ProxyURIContainsFold != nil {
		predicates = append(predicates, implantcallbackconfig.ProxyURIContainsFold(*i.ProxyURIContainsFold))
	}
	if i.Priority != nil {
		predicates = append(predicates, implantcallbackconfig.PriorityEQ(*i.Priority))
	}
	if i.PriorityNEQ != nil {
		predicates = append(predicates, implantcallbackconfig.PriorityNEQ(*i.PriorityNEQ))
	}
	if len(i.PriorityIn) > 0 {
		predicates = append(predicates, implantcallbackconfig.PriorityIn(i.PriorityIn...))
	}
	if len(i.PriorityNotIn) > 0 {
		predicates = append(predicates, implantcallbackconfig.PriorityNotIn(i.PriorityNotIn...))
	}
	if i.PriorityGT != nil {
		predicates = append(predicates, implantcallbackconfig.PriorityGT(*i.PriorityGT))
	}
	if i.PriorityGTE != nil {
		predicates = append(predicates, implantcallbackconfig.PriorityGTE(*i.PriorityGTE))
	}
	if i.PriorityLT != nil {
		predicates = append(predicates, implantcallbackconfig.PriorityLT(*i.PriorityLT))
	}
	if i.PriorityLTE != nil {
		predicates = append(predicates, implantcallbackconfig.PriorityLTE(*i.PriorityLTE))
	}
	if i.Timeout != nil {
		predicates = append(predicates, implantcallbackconfig.TimeoutEQ(*i.Timeout))
	}
	if i.TimeoutNEQ != nil {
		predicates = append(predicates, implantcallbackconfig.TimeoutNEQ(*i.TimeoutNEQ))
	}
	if len(i.TimeoutIn) > 0 {
		predicates = append(predicates, implantcallbackconfig.TimeoutIn(i.TimeoutIn...))
	}
	if len(i.TimeoutNotIn) > 0 {
		predicates = append(predicates, implantcallbackconfig.TimeoutNotIn(i.TimeoutNotIn...))
	}
	if i.TimeoutGT != nil {
		predicates = append(predicates, implantcallbackconfig.TimeoutGT(*i.TimeoutGT))
	}
	if i.TimeoutGTE != nil {
		predicates = append(predicates, implantcallbackconfig.TimeoutGTE(*i.TimeoutGTE))
	}
	if i.TimeoutLT != nil {
		predicates = append(predicates, implantcallbackconfig.TimeoutLT(*i.TimeoutLT))
	}
	if i.TimeoutLTE != nil {
		predicates = append(predicates, implantcallbackconfig.TimeoutLTE(*i.TimeoutLTE))
	}
	if i.Interval != nil {
		predicates = append(predicates, implantcallbackconfig.IntervalEQ(*i.Interval))
	}
	if i.IntervalNEQ != nil {
		predicates = append(predicates, implantcallbackconfig.IntervalNEQ(*i.IntervalNEQ))
	}
	if len(i.IntervalIn) > 0 {
		predicates = append(predicates, implantcallbackconfig.IntervalIn(i.IntervalIn...))
	}
	if len(i.IntervalNotIn) > 0 {
		predicates = append(predicates, implantcallbackconfig.IntervalNotIn(i.IntervalNotIn...))
	}
	if i.IntervalGT != nil {
		predicates = append(predicates, implantcallbackconfig.IntervalGT(*i.IntervalGT))
	}
	if i.IntervalGTE != nil {
		predicates = append(predicates, implantcallbackconfig.IntervalGTE(*i.IntervalGTE))
	}
	if i.IntervalLT != nil {
		predicates = append(predicates, implantcallbackconfig.IntervalLT(*i.IntervalLT))
	}
	if i.IntervalLTE != nil {
		predicates = append(predicates, implantcallbackconfig.IntervalLTE(*i.IntervalLTE))
	}
	if i.Jitter != nil {
		predicates = append(predicates, implantcallbackconfig.JitterEQ(*i.Jitter))
	}
	if i.JitterNEQ != nil {
		predicates = append(predicates, implantcallbackconfig.JitterNEQ(*i.JitterNEQ))
	}
	if len(i.JitterIn) > 0 {
		predicates = append(predicates, implantcallbackconfig.JitterIn(i.JitterIn...))
	}
	if len(i.JitterNotIn) > 0 {
		predicates = append(predicates, implantcallbackconfig.JitterNotIn(i.JitterNotIn...))
	}
	if i.JitterGT != nil {
		predicates = append(predicates, implantcallbackconfig.JitterGT(*i.JitterGT))
	}
	if i.JitterGTE != nil {
		predicates = append(predicates, implantcallbackconfig.JitterGTE(*i.JitterGTE))
	}
	if i.JitterLT != nil {
		predicates = append(predicates, implantcallbackconfig.JitterLT(*i.JitterLT))
	}
	if i.JitterLTE != nil {
		predicates = append(predicates, implantcallbackconfig.JitterLTE(*i.JitterLTE))
	}

	if i.HasImplantConfigs != nil {
		p := implantcallbackconfig.HasImplantConfigs()
		if !*i.HasImplantConfigs {
			p = implantcallbackconfig.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasImplantConfigsWith) > 0 {
		with := make([]predicate.ImplantConfig, 0, len(i.HasImplantConfigsWith))
		for _, w := range i.HasImplantConfigsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, implantcallbackconfig.HasImplantConfigsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/kcarretto/realm/tavern/ent: empty predicate ImplantCallbackConfigWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return implantcallbackconfig.And(predicates...), nil
	}
}

// ImplantConfigWhereInput represents a where input for filtering ImplantConfig queries.
type ImplantConfigWhereInput struct {
	Not *ImplantConfigWhereInput   `json:"not,omitempty"`
	Or  []*ImplantConfigWhereInput `json:"or,omitempty"`
	And []*ImplantConfigWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "authToken" field predicates.
	AuthToken             *string  `json:"authtoken,omitempty"`
	AuthTokenNEQ          *string  `json:"authtokenNEQ,omitempty"`
	AuthTokenIn           []string `json:"authtokenIn,omitempty"`
	AuthTokenNotIn        []string `json:"authtokenNotIn,omitempty"`
	AuthTokenGT           *string  `json:"authtokenGT,omitempty"`
	AuthTokenGTE          *string  `json:"authtokenGTE,omitempty"`
	AuthTokenLT           *string  `json:"authtokenLT,omitempty"`
	AuthTokenLTE          *string  `json:"authtokenLTE,omitempty"`
	AuthTokenContains     *string  `json:"authtokenContains,omitempty"`
	AuthTokenHasPrefix    *string  `json:"authtokenHasPrefix,omitempty"`
	AuthTokenHasSuffix    *string  `json:"authtokenHasSuffix,omitempty"`
	AuthTokenEqualFold    *string  `json:"authtokenEqualFold,omitempty"`
	AuthTokenContainsFold *string  `json:"authtokenContainsFold,omitempty"`

	// "deploymentConfigs" edge predicates.
	HasDeploymentConfigs     *bool                         `json:"hasDeploymentConfigs,omitempty"`
	HasDeploymentConfigsWith []*DeploymentConfigWhereInput `json:"hasDeploymentConfigsWith,omitempty"`

	// "implants" edge predicates.
	HasImplants     *bool                `json:"hasImplants,omitempty"`
	HasImplantsWith []*ImplantWhereInput `json:"hasImplantsWith,omitempty"`

	// "serviceConfigs" edge predicates.
	HasServiceConfigs     *bool                             `json:"hasServiceConfigs,omitempty"`
	HasServiceConfigsWith []*ImplantServiceConfigWhereInput `json:"hasServiceConfigsWith,omitempty"`

	// "callbackConfigs" edge predicates.
	HasCallbackConfigs     *bool                              `json:"hasCallbackConfigs,omitempty"`
	HasCallbackConfigsWith []*ImplantCallbackConfigWhereInput `json:"hasCallbackConfigsWith,omitempty"`
}

// Filter applies the ImplantConfigWhereInput filter on the ImplantConfigQuery builder.
func (i *ImplantConfigWhereInput) Filter(q *ImplantConfigQuery) (*ImplantConfigQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering implantconfigs.
// An error is returned if the input is empty or invalid.
func (i *ImplantConfigWhereInput) P() (predicate.ImplantConfig, error) {
	var predicates []predicate.ImplantConfig
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, implantconfig.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ImplantConfig, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, implantconfig.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ImplantConfig, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, implantconfig.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, implantconfig.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, implantconfig.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, implantconfig.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, implantconfig.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, implantconfig.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, implantconfig.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, implantconfig.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, implantconfig.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, implantconfig.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, implantconfig.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, implantconfig.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, implantconfig.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, implantconfig.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, implantconfig.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, implantconfig.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, implantconfig.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, implantconfig.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, implantconfig.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, implantconfig.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, implantconfig.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, implantconfig.NameContainsFold(*i.NameContainsFold))
	}
	if i.AuthToken != nil {
		predicates = append(predicates, implantconfig.AuthTokenEQ(*i.AuthToken))
	}
	if i.AuthTokenNEQ != nil {
		predicates = append(predicates, implantconfig.AuthTokenNEQ(*i.AuthTokenNEQ))
	}
	if len(i.AuthTokenIn) > 0 {
		predicates = append(predicates, implantconfig.AuthTokenIn(i.AuthTokenIn...))
	}
	if len(i.AuthTokenNotIn) > 0 {
		predicates = append(predicates, implantconfig.AuthTokenNotIn(i.AuthTokenNotIn...))
	}
	if i.AuthTokenGT != nil {
		predicates = append(predicates, implantconfig.AuthTokenGT(*i.AuthTokenGT))
	}
	if i.AuthTokenGTE != nil {
		predicates = append(predicates, implantconfig.AuthTokenGTE(*i.AuthTokenGTE))
	}
	if i.AuthTokenLT != nil {
		predicates = append(predicates, implantconfig.AuthTokenLT(*i.AuthTokenLT))
	}
	if i.AuthTokenLTE != nil {
		predicates = append(predicates, implantconfig.AuthTokenLTE(*i.AuthTokenLTE))
	}
	if i.AuthTokenContains != nil {
		predicates = append(predicates, implantconfig.AuthTokenContains(*i.AuthTokenContains))
	}
	if i.AuthTokenHasPrefix != nil {
		predicates = append(predicates, implantconfig.AuthTokenHasPrefix(*i.AuthTokenHasPrefix))
	}
	if i.AuthTokenHasSuffix != nil {
		predicates = append(predicates, implantconfig.AuthTokenHasSuffix(*i.AuthTokenHasSuffix))
	}
	if i.AuthTokenEqualFold != nil {
		predicates = append(predicates, implantconfig.AuthTokenEqualFold(*i.AuthTokenEqualFold))
	}
	if i.AuthTokenContainsFold != nil {
		predicates = append(predicates, implantconfig.AuthTokenContainsFold(*i.AuthTokenContainsFold))
	}

	if i.HasDeploymentConfigs != nil {
		p := implantconfig.HasDeploymentConfigs()
		if !*i.HasDeploymentConfigs {
			p = implantconfig.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeploymentConfigsWith) > 0 {
		with := make([]predicate.DeploymentConfig, 0, len(i.HasDeploymentConfigsWith))
		for _, w := range i.HasDeploymentConfigsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, implantconfig.HasDeploymentConfigsWith(with...))
	}
	if i.HasImplants != nil {
		p := implantconfig.HasImplants()
		if !*i.HasImplants {
			p = implantconfig.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasImplantsWith) > 0 {
		with := make([]predicate.Implant, 0, len(i.HasImplantsWith))
		for _, w := range i.HasImplantsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, implantconfig.HasImplantsWith(with...))
	}
	if i.HasServiceConfigs != nil {
		p := implantconfig.HasServiceConfigs()
		if !*i.HasServiceConfigs {
			p = implantconfig.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServiceConfigsWith) > 0 {
		with := make([]predicate.ImplantServiceConfig, 0, len(i.HasServiceConfigsWith))
		for _, w := range i.HasServiceConfigsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, implantconfig.HasServiceConfigsWith(with...))
	}
	if i.HasCallbackConfigs != nil {
		p := implantconfig.HasCallbackConfigs()
		if !*i.HasCallbackConfigs {
			p = implantconfig.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCallbackConfigsWith) > 0 {
		with := make([]predicate.ImplantCallbackConfig, 0, len(i.HasCallbackConfigsWith))
		for _, w := range i.HasCallbackConfigsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, implantconfig.HasCallbackConfigsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/kcarretto/realm/tavern/ent: empty predicate ImplantConfigWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return implantconfig.And(predicates...), nil
	}
}

// ImplantServiceConfigWhereInput represents a where input for filtering ImplantServiceConfig queries.
type ImplantServiceConfigWhereInput struct {
	Not *ImplantServiceConfigWhereInput   `json:"not,omitempty"`
	Or  []*ImplantServiceConfigWhereInput `json:"or,omitempty"`
	And []*ImplantServiceConfigWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "executablePath" field predicates.
	ExecutablePath             *string  `json:"executablepath,omitempty"`
	ExecutablePathNEQ          *string  `json:"executablepathNEQ,omitempty"`
	ExecutablePathIn           []string `json:"executablepathIn,omitempty"`
	ExecutablePathNotIn        []string `json:"executablepathNotIn,omitempty"`
	ExecutablePathGT           *string  `json:"executablepathGT,omitempty"`
	ExecutablePathGTE          *string  `json:"executablepathGTE,omitempty"`
	ExecutablePathLT           *string  `json:"executablepathLT,omitempty"`
	ExecutablePathLTE          *string  `json:"executablepathLTE,omitempty"`
	ExecutablePathContains     *string  `json:"executablepathContains,omitempty"`
	ExecutablePathHasPrefix    *string  `json:"executablepathHasPrefix,omitempty"`
	ExecutablePathHasSuffix    *string  `json:"executablepathHasSuffix,omitempty"`
	ExecutablePathEqualFold    *string  `json:"executablepathEqualFold,omitempty"`
	ExecutablePathContainsFold *string  `json:"executablepathContainsFold,omitempty"`

	// "implantConfigs" edge predicates.
	HasImplantConfigs     *bool                      `json:"hasImplantConfigs,omitempty"`
	HasImplantConfigsWith []*ImplantConfigWhereInput `json:"hasImplantConfigsWith,omitempty"`
}

// Filter applies the ImplantServiceConfigWhereInput filter on the ImplantServiceConfigQuery builder.
func (i *ImplantServiceConfigWhereInput) Filter(q *ImplantServiceConfigQuery) (*ImplantServiceConfigQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering implantserviceconfigs.
// An error is returned if the input is empty or invalid.
func (i *ImplantServiceConfigWhereInput) P() (predicate.ImplantServiceConfig, error) {
	var predicates []predicate.ImplantServiceConfig
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, implantserviceconfig.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ImplantServiceConfig, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, implantserviceconfig.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ImplantServiceConfig, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, implantserviceconfig.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, implantserviceconfig.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, implantserviceconfig.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, implantserviceconfig.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, implantserviceconfig.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, implantserviceconfig.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, implantserviceconfig.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, implantserviceconfig.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, implantserviceconfig.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, implantserviceconfig.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, implantserviceconfig.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, implantserviceconfig.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, implantserviceconfig.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, implantserviceconfig.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, implantserviceconfig.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, implantserviceconfig.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, implantserviceconfig.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, implantserviceconfig.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, implantserviceconfig.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, implantserviceconfig.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, implantserviceconfig.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, implantserviceconfig.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, implantserviceconfig.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, implantserviceconfig.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, implantserviceconfig.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, implantserviceconfig.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, implantserviceconfig.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, implantserviceconfig.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, implantserviceconfig.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, implantserviceconfig.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, implantserviceconfig.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, implantserviceconfig.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, implantserviceconfig.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, implantserviceconfig.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, implantserviceconfig.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ExecutablePath != nil {
		predicates = append(predicates, implantserviceconfig.ExecutablePathEQ(*i.ExecutablePath))
	}
	if i.ExecutablePathNEQ != nil {
		predicates = append(predicates, implantserviceconfig.ExecutablePathNEQ(*i.ExecutablePathNEQ))
	}
	if len(i.ExecutablePathIn) > 0 {
		predicates = append(predicates, implantserviceconfig.ExecutablePathIn(i.ExecutablePathIn...))
	}
	if len(i.ExecutablePathNotIn) > 0 {
		predicates = append(predicates, implantserviceconfig.ExecutablePathNotIn(i.ExecutablePathNotIn...))
	}
	if i.ExecutablePathGT != nil {
		predicates = append(predicates, implantserviceconfig.ExecutablePathGT(*i.ExecutablePathGT))
	}
	if i.ExecutablePathGTE != nil {
		predicates = append(predicates, implantserviceconfig.ExecutablePathGTE(*i.ExecutablePathGTE))
	}
	if i.ExecutablePathLT != nil {
		predicates = append(predicates, implantserviceconfig.ExecutablePathLT(*i.ExecutablePathLT))
	}
	if i.ExecutablePathLTE != nil {
		predicates = append(predicates, implantserviceconfig.ExecutablePathLTE(*i.ExecutablePathLTE))
	}
	if i.ExecutablePathContains != nil {
		predicates = append(predicates, implantserviceconfig.ExecutablePathContains(*i.ExecutablePathContains))
	}
	if i.ExecutablePathHasPrefix != nil {
		predicates = append(predicates, implantserviceconfig.ExecutablePathHasPrefix(*i.ExecutablePathHasPrefix))
	}
	if i.ExecutablePathHasSuffix != nil {
		predicates = append(predicates, implantserviceconfig.ExecutablePathHasSuffix(*i.ExecutablePathHasSuffix))
	}
	if i.ExecutablePathEqualFold != nil {
		predicates = append(predicates, implantserviceconfig.ExecutablePathEqualFold(*i.ExecutablePathEqualFold))
	}
	if i.ExecutablePathContainsFold != nil {
		predicates = append(predicates, implantserviceconfig.ExecutablePathContainsFold(*i.ExecutablePathContainsFold))
	}

	if i.HasImplantConfigs != nil {
		p := implantserviceconfig.HasImplantConfigs()
		if !*i.HasImplantConfigs {
			p = implantserviceconfig.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasImplantConfigsWith) > 0 {
		with := make([]predicate.ImplantConfig, 0, len(i.HasImplantConfigsWith))
		for _, w := range i.HasImplantConfigsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, implantserviceconfig.HasImplantConfigsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/kcarretto/realm/tavern/ent: empty predicate ImplantServiceConfigWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return implantserviceconfig.And(predicates...), nil
	}
}

// TagWhereInput represents a where input for filtering Tag queries.
type TagWhereInput struct {
	Not *TagWhereInput   `json:"not,omitempty"`
	Or  []*TagWhereInput `json:"or,omitempty"`
	And []*TagWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "targets" edge predicates.
	HasTargets     *bool               `json:"hasTargets,omitempty"`
	HasTargetsWith []*TargetWhereInput `json:"hasTargetsWith,omitempty"`
}

// Filter applies the TagWhereInput filter on the TagQuery builder.
func (i *TagWhereInput) Filter(q *TagQuery) (*TagQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering tags.
// An error is returned if the input is empty or invalid.
func (i *TagWhereInput) P() (predicate.Tag, error) {
	var predicates []predicate.Tag
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, tag.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Tag, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, tag.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Tag, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, tag.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, tag.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, tag.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, tag.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, tag.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, tag.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, tag.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, tag.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, tag.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, tag.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, tag.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, tag.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, tag.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, tag.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, tag.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, tag.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, tag.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, tag.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, tag.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, tag.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, tag.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, tag.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasTargets != nil {
		p := tag.HasTargets()
		if !*i.HasTargets {
			p = tag.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTargetsWith) > 0 {
		with := make([]predicate.Target, 0, len(i.HasTargetsWith))
		for _, w := range i.HasTargetsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, tag.HasTargetsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/kcarretto/realm/tavern/ent: empty predicate TagWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return tag.And(predicates...), nil
	}
}

// TargetWhereInput represents a where input for filtering Target queries.
type TargetWhereInput struct {
	Not *TargetWhereInput   `json:"not,omitempty"`
	Or  []*TargetWhereInput `json:"or,omitempty"`
	And []*TargetWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "forwardConnectIP" field predicates.
	ForwardConnectIP             *string  `json:"forwardconnectip,omitempty"`
	ForwardConnectIPNEQ          *string  `json:"forwardconnectipNEQ,omitempty"`
	ForwardConnectIPIn           []string `json:"forwardconnectipIn,omitempty"`
	ForwardConnectIPNotIn        []string `json:"forwardconnectipNotIn,omitempty"`
	ForwardConnectIPGT           *string  `json:"forwardconnectipGT,omitempty"`
	ForwardConnectIPGTE          *string  `json:"forwardconnectipGTE,omitempty"`
	ForwardConnectIPLT           *string  `json:"forwardconnectipLT,omitempty"`
	ForwardConnectIPLTE          *string  `json:"forwardconnectipLTE,omitempty"`
	ForwardConnectIPContains     *string  `json:"forwardconnectipContains,omitempty"`
	ForwardConnectIPHasPrefix    *string  `json:"forwardconnectipHasPrefix,omitempty"`
	ForwardConnectIPHasSuffix    *string  `json:"forwardconnectipHasSuffix,omitempty"`
	ForwardConnectIPEqualFold    *string  `json:"forwardconnectipEqualFold,omitempty"`
	ForwardConnectIPContainsFold *string  `json:"forwardconnectipContainsFold,omitempty"`

	// "implants" edge predicates.
	HasImplants     *bool                `json:"hasImplants,omitempty"`
	HasImplantsWith []*ImplantWhereInput `json:"hasImplantsWith,omitempty"`

	// "deployments" edge predicates.
	HasDeployments     *bool                   `json:"hasDeployments,omitempty"`
	HasDeploymentsWith []*DeploymentWhereInput `json:"hasDeploymentsWith,omitempty"`

	// "credentials" edge predicates.
	HasCredentials     *bool                   `json:"hasCredentials,omitempty"`
	HasCredentialsWith []*CredentialWhereInput `json:"hasCredentialsWith,omitempty"`

	// "tags" edge predicates.
	HasTags     *bool            `json:"hasTags,omitempty"`
	HasTagsWith []*TagWhereInput `json:"hasTagsWith,omitempty"`
}

// Filter applies the TargetWhereInput filter on the TargetQuery builder.
func (i *TargetWhereInput) Filter(q *TargetQuery) (*TargetQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering targets.
// An error is returned if the input is empty or invalid.
func (i *TargetWhereInput) P() (predicate.Target, error) {
	var predicates []predicate.Target
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, target.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Target, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, target.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Target, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, target.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, target.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, target.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, target.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, target.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, target.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, target.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, target.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, target.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, target.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, target.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, target.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, target.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, target.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, target.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, target.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, target.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, target.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, target.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, target.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, target.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, target.NameContainsFold(*i.NameContainsFold))
	}
	if i.ForwardConnectIP != nil {
		predicates = append(predicates, target.ForwardConnectIPEQ(*i.ForwardConnectIP))
	}
	if i.ForwardConnectIPNEQ != nil {
		predicates = append(predicates, target.ForwardConnectIPNEQ(*i.ForwardConnectIPNEQ))
	}
	if len(i.ForwardConnectIPIn) > 0 {
		predicates = append(predicates, target.ForwardConnectIPIn(i.ForwardConnectIPIn...))
	}
	if len(i.ForwardConnectIPNotIn) > 0 {
		predicates = append(predicates, target.ForwardConnectIPNotIn(i.ForwardConnectIPNotIn...))
	}
	if i.ForwardConnectIPGT != nil {
		predicates = append(predicates, target.ForwardConnectIPGT(*i.ForwardConnectIPGT))
	}
	if i.ForwardConnectIPGTE != nil {
		predicates = append(predicates, target.ForwardConnectIPGTE(*i.ForwardConnectIPGTE))
	}
	if i.ForwardConnectIPLT != nil {
		predicates = append(predicates, target.ForwardConnectIPLT(*i.ForwardConnectIPLT))
	}
	if i.ForwardConnectIPLTE != nil {
		predicates = append(predicates, target.ForwardConnectIPLTE(*i.ForwardConnectIPLTE))
	}
	if i.ForwardConnectIPContains != nil {
		predicates = append(predicates, target.ForwardConnectIPContains(*i.ForwardConnectIPContains))
	}
	if i.ForwardConnectIPHasPrefix != nil {
		predicates = append(predicates, target.ForwardConnectIPHasPrefix(*i.ForwardConnectIPHasPrefix))
	}
	if i.ForwardConnectIPHasSuffix != nil {
		predicates = append(predicates, target.ForwardConnectIPHasSuffix(*i.ForwardConnectIPHasSuffix))
	}
	if i.ForwardConnectIPEqualFold != nil {
		predicates = append(predicates, target.ForwardConnectIPEqualFold(*i.ForwardConnectIPEqualFold))
	}
	if i.ForwardConnectIPContainsFold != nil {
		predicates = append(predicates, target.ForwardConnectIPContainsFold(*i.ForwardConnectIPContainsFold))
	}

	if i.HasImplants != nil {
		p := target.HasImplants()
		if !*i.HasImplants {
			p = target.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasImplantsWith) > 0 {
		with := make([]predicate.Implant, 0, len(i.HasImplantsWith))
		for _, w := range i.HasImplantsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, target.HasImplantsWith(with...))
	}
	if i.HasDeployments != nil {
		p := target.HasDeployments()
		if !*i.HasDeployments {
			p = target.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeploymentsWith) > 0 {
		with := make([]predicate.Deployment, 0, len(i.HasDeploymentsWith))
		for _, w := range i.HasDeploymentsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, target.HasDeploymentsWith(with...))
	}
	if i.HasCredentials != nil {
		p := target.HasCredentials()
		if !*i.HasCredentials {
			p = target.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCredentialsWith) > 0 {
		with := make([]predicate.Credential, 0, len(i.HasCredentialsWith))
		for _, w := range i.HasCredentialsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, target.HasCredentialsWith(with...))
	}
	if i.HasTags != nil {
		p := target.HasTags()
		if !*i.HasTags {
			p = target.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTagsWith) > 0 {
		with := make([]predicate.Tag, 0, len(i.HasTagsWith))
		for _, w := range i.HasTagsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, target.HasTagsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/kcarretto/realm/tavern/ent: empty predicate TargetWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return target.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "Name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "OAuthID" field predicates.
	OAuthID             *string  `json:"oauthid,omitempty"`
	OAuthIDNEQ          *string  `json:"oauthidNEQ,omitempty"`
	OAuthIDIn           []string `json:"oauthidIn,omitempty"`
	OAuthIDNotIn        []string `json:"oauthidNotIn,omitempty"`
	OAuthIDGT           *string  `json:"oauthidGT,omitempty"`
	OAuthIDGTE          *string  `json:"oauthidGTE,omitempty"`
	OAuthIDLT           *string  `json:"oauthidLT,omitempty"`
	OAuthIDLTE          *string  `json:"oauthidLTE,omitempty"`
	OAuthIDContains     *string  `json:"oauthidContains,omitempty"`
	OAuthIDHasPrefix    *string  `json:"oauthidHasPrefix,omitempty"`
	OAuthIDHasSuffix    *string  `json:"oauthidHasSuffix,omitempty"`
	OAuthIDEqualFold    *string  `json:"oauthidEqualFold,omitempty"`
	OAuthIDContainsFold *string  `json:"oauthidContainsFold,omitempty"`

	// "PhotoURL" field predicates.
	PhotoURL             *string  `json:"photourl,omitempty"`
	PhotoURLNEQ          *string  `json:"photourlNEQ,omitempty"`
	PhotoURLIn           []string `json:"photourlIn,omitempty"`
	PhotoURLNotIn        []string `json:"photourlNotIn,omitempty"`
	PhotoURLGT           *string  `json:"photourlGT,omitempty"`
	PhotoURLGTE          *string  `json:"photourlGTE,omitempty"`
	PhotoURLLT           *string  `json:"photourlLT,omitempty"`
	PhotoURLLTE          *string  `json:"photourlLTE,omitempty"`
	PhotoURLContains     *string  `json:"photourlContains,omitempty"`
	PhotoURLHasPrefix    *string  `json:"photourlHasPrefix,omitempty"`
	PhotoURLHasSuffix    *string  `json:"photourlHasSuffix,omitempty"`
	PhotoURLEqualFold    *string  `json:"photourlEqualFold,omitempty"`
	PhotoURLContainsFold *string  `json:"photourlContainsFold,omitempty"`

	// "SessionToken" field predicates.
	SessionToken             *string  `json:"sessiontoken,omitempty"`
	SessionTokenNEQ          *string  `json:"sessiontokenNEQ,omitempty"`
	SessionTokenIn           []string `json:"sessiontokenIn,omitempty"`
	SessionTokenNotIn        []string `json:"sessiontokenNotIn,omitempty"`
	SessionTokenGT           *string  `json:"sessiontokenGT,omitempty"`
	SessionTokenGTE          *string  `json:"sessiontokenGTE,omitempty"`
	SessionTokenLT           *string  `json:"sessiontokenLT,omitempty"`
	SessionTokenLTE          *string  `json:"sessiontokenLTE,omitempty"`
	SessionTokenContains     *string  `json:"sessiontokenContains,omitempty"`
	SessionTokenHasPrefix    *string  `json:"sessiontokenHasPrefix,omitempty"`
	SessionTokenHasSuffix    *string  `json:"sessiontokenHasSuffix,omitempty"`
	SessionTokenEqualFold    *string  `json:"sessiontokenEqualFold,omitempty"`
	SessionTokenContainsFold *string  `json:"sessiontokenContainsFold,omitempty"`

	// "IsActivated" field predicates.
	IsActivated    *bool `json:"isactivated,omitempty"`
	IsActivatedNEQ *bool `json:"isactivatedNEQ,omitempty"`

	// "IsAdmin" field predicates.
	IsAdmin    *bool `json:"isadmin,omitempty"`
	IsAdminNEQ *bool `json:"isadminNEQ,omitempty"`
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.OAuthID != nil {
		predicates = append(predicates, user.OAuthIDEQ(*i.OAuthID))
	}
	if i.OAuthIDNEQ != nil {
		predicates = append(predicates, user.OAuthIDNEQ(*i.OAuthIDNEQ))
	}
	if len(i.OAuthIDIn) > 0 {
		predicates = append(predicates, user.OAuthIDIn(i.OAuthIDIn...))
	}
	if len(i.OAuthIDNotIn) > 0 {
		predicates = append(predicates, user.OAuthIDNotIn(i.OAuthIDNotIn...))
	}
	if i.OAuthIDGT != nil {
		predicates = append(predicates, user.OAuthIDGT(*i.OAuthIDGT))
	}
	if i.OAuthIDGTE != nil {
		predicates = append(predicates, user.OAuthIDGTE(*i.OAuthIDGTE))
	}
	if i.OAuthIDLT != nil {
		predicates = append(predicates, user.OAuthIDLT(*i.OAuthIDLT))
	}
	if i.OAuthIDLTE != nil {
		predicates = append(predicates, user.OAuthIDLTE(*i.OAuthIDLTE))
	}
	if i.OAuthIDContains != nil {
		predicates = append(predicates, user.OAuthIDContains(*i.OAuthIDContains))
	}
	if i.OAuthIDHasPrefix != nil {
		predicates = append(predicates, user.OAuthIDHasPrefix(*i.OAuthIDHasPrefix))
	}
	if i.OAuthIDHasSuffix != nil {
		predicates = append(predicates, user.OAuthIDHasSuffix(*i.OAuthIDHasSuffix))
	}
	if i.OAuthIDEqualFold != nil {
		predicates = append(predicates, user.OAuthIDEqualFold(*i.OAuthIDEqualFold))
	}
	if i.OAuthIDContainsFold != nil {
		predicates = append(predicates, user.OAuthIDContainsFold(*i.OAuthIDContainsFold))
	}
	if i.PhotoURL != nil {
		predicates = append(predicates, user.PhotoURLEQ(*i.PhotoURL))
	}
	if i.PhotoURLNEQ != nil {
		predicates = append(predicates, user.PhotoURLNEQ(*i.PhotoURLNEQ))
	}
	if len(i.PhotoURLIn) > 0 {
		predicates = append(predicates, user.PhotoURLIn(i.PhotoURLIn...))
	}
	if len(i.PhotoURLNotIn) > 0 {
		predicates = append(predicates, user.PhotoURLNotIn(i.PhotoURLNotIn...))
	}
	if i.PhotoURLGT != nil {
		predicates = append(predicates, user.PhotoURLGT(*i.PhotoURLGT))
	}
	if i.PhotoURLGTE != nil {
		predicates = append(predicates, user.PhotoURLGTE(*i.PhotoURLGTE))
	}
	if i.PhotoURLLT != nil {
		predicates = append(predicates, user.PhotoURLLT(*i.PhotoURLLT))
	}
	if i.PhotoURLLTE != nil {
		predicates = append(predicates, user.PhotoURLLTE(*i.PhotoURLLTE))
	}
	if i.PhotoURLContains != nil {
		predicates = append(predicates, user.PhotoURLContains(*i.PhotoURLContains))
	}
	if i.PhotoURLHasPrefix != nil {
		predicates = append(predicates, user.PhotoURLHasPrefix(*i.PhotoURLHasPrefix))
	}
	if i.PhotoURLHasSuffix != nil {
		predicates = append(predicates, user.PhotoURLHasSuffix(*i.PhotoURLHasSuffix))
	}
	if i.PhotoURLEqualFold != nil {
		predicates = append(predicates, user.PhotoURLEqualFold(*i.PhotoURLEqualFold))
	}
	if i.PhotoURLContainsFold != nil {
		predicates = append(predicates, user.PhotoURLContainsFold(*i.PhotoURLContainsFold))
	}
	if i.SessionToken != nil {
		predicates = append(predicates, user.SessionTokenEQ(*i.SessionToken))
	}
	if i.SessionTokenNEQ != nil {
		predicates = append(predicates, user.SessionTokenNEQ(*i.SessionTokenNEQ))
	}
	if len(i.SessionTokenIn) > 0 {
		predicates = append(predicates, user.SessionTokenIn(i.SessionTokenIn...))
	}
	if len(i.SessionTokenNotIn) > 0 {
		predicates = append(predicates, user.SessionTokenNotIn(i.SessionTokenNotIn...))
	}
	if i.SessionTokenGT != nil {
		predicates = append(predicates, user.SessionTokenGT(*i.SessionTokenGT))
	}
	if i.SessionTokenGTE != nil {
		predicates = append(predicates, user.SessionTokenGTE(*i.SessionTokenGTE))
	}
	if i.SessionTokenLT != nil {
		predicates = append(predicates, user.SessionTokenLT(*i.SessionTokenLT))
	}
	if i.SessionTokenLTE != nil {
		predicates = append(predicates, user.SessionTokenLTE(*i.SessionTokenLTE))
	}
	if i.SessionTokenContains != nil {
		predicates = append(predicates, user.SessionTokenContains(*i.SessionTokenContains))
	}
	if i.SessionTokenHasPrefix != nil {
		predicates = append(predicates, user.SessionTokenHasPrefix(*i.SessionTokenHasPrefix))
	}
	if i.SessionTokenHasSuffix != nil {
		predicates = append(predicates, user.SessionTokenHasSuffix(*i.SessionTokenHasSuffix))
	}
	if i.SessionTokenEqualFold != nil {
		predicates = append(predicates, user.SessionTokenEqualFold(*i.SessionTokenEqualFold))
	}
	if i.SessionTokenContainsFold != nil {
		predicates = append(predicates, user.SessionTokenContainsFold(*i.SessionTokenContainsFold))
	}
	if i.IsActivated != nil {
		predicates = append(predicates, user.IsActivatedEQ(*i.IsActivated))
	}
	if i.IsActivatedNEQ != nil {
		predicates = append(predicates, user.IsActivatedNEQ(*i.IsActivatedNEQ))
	}
	if i.IsAdmin != nil {
		predicates = append(predicates, user.IsAdminEQ(*i.IsAdmin))
	}
	if i.IsAdminNEQ != nil {
		predicates = append(predicates, user.IsAdminNEQ(*i.IsAdminNEQ))
	}

	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/kcarretto/realm/tavern/ent: empty predicate UserWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
